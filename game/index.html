<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Loki: The Trickster's Trial</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@700&family=Cinzel:wght@400;700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="../style.css">
</head>

<body>
    <audio id="bg-music" loop>
        <source src="music/game.mp3" type="audio/mpeg">
    </audio>
    <audio id="gameover-music" loop>
        <source src="music/gameover.mp3" type="audio/mpeg">
    </audio>

    <div id="notification-container"></div>
    <div id="transition-overlay">
        <h2 id="transition-realm-name">Entering the Void</h2>
        <p id="transition-realm-desc"
            style="color: #ccc; font-family: 'Cormorant Garamond'; font-style: italic; font-size: 1.4em; max-width: 600px; line-height: 1.6; margin-top: 20px;">
        </p>
        <p style="color: #666; font-family: 'Cinzel'; letter-spacing: 5px; margin-top: 30px;">Wait for the Norns</p>
    </div>

    <div id="death-screen">
        <h1 id="death-title">YOU PERISHED</h1>
        <p id="death-msg"></p>

        <div id="score-submit-container">
            <h3>Record your Legend</h3>
            <p>Runes: <span id="final-score">0</span></p>
            <input type="text" id="player-name" placeholder="Enter Hero Name" maxlength="15">
            <button id="submit-score-btn" onclick="submitScore()">Submit to Hall of Heroes</button>
        </div>

        <button onclick="location.reload()" style="margin-top: 20px;">REBORN</button>
    </div>

    <div id="name-modal" class="modal" style="display: none; z-index: 10002;">
        <div class="modal-content" style="text-align: center; height: auto; width: 450px;">
            <h2 style="color: var(--gold); font-family: 'Cinzel'; margin-top: 10px;">Whom do you represent?</h2>
            <p style="color: #ccc; font-style: italic; margin-bottom: 25px;">Enter your name to begin your journey
                through the Nine Realms.</p>
            <input type="text" id="initial-player-name" placeholder="Enter Legend Name" maxlength="15"
                style="background: #000; border: 1px solid var(--gold); color: var(--gold); padding: 12px; font-family: 'Cinzel', serif; text-align: center; font-size: 1.25em; width: 80%; margin-bottom: 25px; outline: none; box-shadow: 0 0 10px rgba(212, 175, 55, 0.2);">
            <div style="margin-bottom: 10px;">
                <button id="start-game-btn" onclick="startGameWithName()"
                    style="font-size: 1.2em; padding: 15px 50px;">Ascend</button>
            </div>
        </div>
    </div>


    <h1>LOKI</h1>
    <p class="instructions">"Glorious purpose awaits." Use WASD to traverse the Nine Realms. Collect Runes and find your
        Daggers to strike down enemies (1) or use Mischief (2) to confuse them. Collect <b>Space Stone fragments</b> to
        forge <b>Portals (P)</b> and skip through the void.</p>





    <div id="gatekeeper-modal" class="modal">
        <div class="modal-content">
            <h2 style="color: var(--gold); font-family: 'Cinzel';">The Gatekeeper's Trial</h2>
            <p id="gate-question-text" style="font-size: 1.2em; margin-bottom: 20px;"></p>

            <div id="gate-options-container"
                style="display: flex; flex-direction: column; gap: 10px; width: 80%; margin: 0 auto;"></div>

            <div style="margin-top: 20px; border-top: 1px solid #333; padding-top: 15px;">
                <button id="hint-btn" onclick="buyHint()"
                    style="background: #443300; border: 1px solid var(--gold); color: var(--gold); cursor: pointer; padding: 5px 10px;">
                    Buy Hint (150 Runes)
                </button>
                <p id="gate-hint-text" style="color: #aaa; font-style: italic; margin-top: 10px; display: none;"></p>
            </div>

            <p id="gate-feedback" style="margin-top: 15px; font-weight: bold;"></p>
        </div>
    </div>



    <div id="fight-modal" class="modal">
        <div class="modal-content fight-content">
            <iframe id="fight-frame" class="fight-frame" src=""></iframe>
        </div>
    </div>

    <div id="cutscene-modal" class="modal" style="background: black; z-index: 2000; display: none;">
        <video id="cutscene-video" style="width: 100%; height: 100%; object-fit: contain;" playsinline></video>
    </div>
    <div id="mischief-modal" class="modal">
        <div class="modal-content">
            <h2>Cast an Illusion</h2>
            <p id="mischief-target-info"></p>
            <textarea id="mischief-input" placeholder="Type how you will confuse this foe..."></textarea>
            <div class="modal-buttons">
                <button id="mischief-submit" onclick="submitMischief()">Deceive</button>
                <button onclick="closeMischief()">Withdraw</button>
            </div>
            <div id="mischief-result" class="mischief-result"></div>
        </div>
    </div>
    <div id="top-hud">
        <div class="hud-item" title="Current Realm">
            <span class="hud-label">Realm</span>
            <span id="level-text" class="hud-value">1</span>
        </div>
        <div class="hud-item" title="Vitality">
            <span class="hud-label">Health</span>
            <div class="hud-stat-group">
                <span class="hud-icon">‚ù§Ô∏è</span>
                <span id="health-text" class="hud-value">100</span>
            </div>
        </div>
        <div class="hud-item" title="Runes Collected">
            <span class="hud-label">Runes</span>
            <div class="hud-stat-group">
                <span class="hud-icon">‚ú®</span>
                <span id="score-text" class="hud-value">0</span>
            </div>
        </div>
        <div class="hud-item" title="Space Stone Fragments">
            <span class="hud-label">Fragments</span>
            <div class="hud-stat-group">
                <span class="hud-icon" style="color: #00d4ff;">üíé</span>
                <span id="stone-text" class="hud-value" style="color: #00d4ff;">0</span>
            </div>
        </div>
        <div class="hud-item" title="Available Portals (Press P)">
            <span class="hud-label">Portals</span>
            <div class="hud-stat-group">
                <span class="hud-icon" style="color: #00ff41;">üåÄ</span>
                <span id="portal-text" class="hud-value" style="color: #00ff41;">0</span>
            </div>
        </div>
        <div class="hud-item" title="Mischief Charges (Press 2)">
            <span class="hud-label">Mischief</span>
            <div class="hud-stat-group">
                <span class="hud-icon">üé≠</span>
                <span id="mischief-status" class="hud-value">1</span>
            </div>
        </div>
        <div class="hud-item" title="Dagger Durability (Press 1)">
            <span class="hud-label">Daggers</span>
            <div class="hud-stat-group">
                <span class="hud-icon">üó°Ô∏è</span>
                <span id="weapon-text" class="hud-value">0</span>
            </div>
        </div>
    </div>

    <div id="side-hud">
        <button class="side-item" onclick="openLeaderboard()" title="Hall of Heroes">
            <span class="side-icon">üèÜ</span>
            <span class="side-label">Heroes</span>
        </button>
        <button class="side-item" onclick="playHowTo()" title="Instructions">
            <span class="side-icon">‚ùì</span>
            <span class="side-label">Guide</span>
        </button>
        <button class="side-item" onclick="toggleGridView()" title="Toggle View Mode">
            <span class="side-icon">üëÅÔ∏è</span>
            <span id="view-text-side" class="side-label">Standard</span>
        </button>
        <button class="side-item" onclick="openCredits()" title="Credits">
            <span class="side-icon">üìú</span>
            <span class="side-label">Credits</span>
        </button>
    </div>

    <!-- Credits Modal -->
    <div id="credits-modal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeCredits()">&times;</span>
            <iframe src="../credits/index.html" style="width: 100%; height: 100%; border: none;"></iframe>
        </div>
    </div>

    <!-- Leaderboard Modal -->
    <div id="leaderboard-modal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeLeaderboard()">&times;</span>
            <h2 style="text-align: center;">Hall of Heroes</h2>
            <div id="leaderboard-loading" style="text-align: center; color: var(--gold);">Communing with the Norns...
            </div>
            <table class="leaderboard-table" id="leaderboard-table" style="display: none;">
                <thead>
                    <tr>
                        <th>Hero</th>
                        <th>Runes</th>
                        <th>Realm</th>
                    </tr>
                </thead>
                <tbody id="leaderboard-body"></tbody>
            </table>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <!-- Image assets -->
    <div class="preload">
        <img id="hero-idle-weapon" src="hero/1.png" alt="hero idle weapon">
        <img id="hero-idle-no-weapon" src="hero/2.png" alt="hero idle no weapon">
        <img id="hero-run-1" src="hero/3.png" alt="hero run 1">
        <img id="hero-run-2" src="hero/4.png" alt="hero run 2">
        <img id="hero-run-3" src="hero/5.png" alt="hero run 3">
        <img id="hero-run-4" src="hero/6.png" alt="hero run 4">
        <img id="enemy-img" src="enemy.png" alt="enemy">
        <img id="enemy2-img" src="enemy2.png" alt="enemy elite">
        <img id="enemy3-img" src="enemy3.png" alt="enemy boss">
        <img id="coin-img" src="coin.png" alt="coin">
        <img id="weapon-img" src="sword.png" alt="weapon">
        <img id="potion-img" src="potion1.png" alt="health potion">
    </div>

    <script type="module">

        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-app.js";
        import { getFirestore, collection, addDoc, query, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyAPnWpytVCOF5UfryHEDCVe0fEs-Vx1xSE",
            authDomain: "loki-2dcab.firebaseapp.com",
            projectId: "loki-2dcab",
            storageBucket: "loki-2dcab.firebasestorage.app",
            messagingSenderId: "710391143408",
            appId: "1:710391143408:web:48667f1adfddbff5a15b35"
        };

        let db;
        let isFirebaseInitialized = false;

        window.debugGame = function () {
            console.log("--- LOKI GAME DEBUG ---");
            console.log("Level:", level);
            console.log("Player State:", player);
            console.log("Enemies Count:", enemies.length);
            console.log("Collectibles Count:", collectibles.length);
            console.log("Is Paused:", isPaused);
            console.log("Is Game Over:", isGameOver);
            console.log("Canvas Size:", canvas.width, "x", canvas.height);
            console.log("Assets Loaded Status:");
            for (let key in assets) {
                if (Array.isArray(assets[key])) {
                    assets[key].forEach((img, i) => console.log(`  ${key}[${i}]: ${img.complete ? 'COMPLETE' : 'LOADING'} (${img.src})`));
                } else {
                    console.log(`  ${key}: ${assets[key] ? (assets[key].complete ? 'COMPLETE' : 'LOADING') : 'NULL'} (${assets[key]?.src})`);
                }
            }
            return "Debug log finished.";
        };

        window.onerror = function (msg, url, line, col, error) {
            console.error("GLOBAL GAME ERROR:", msg, "at", url, ":", line, ":", col, error);
            return false;
        };

        try {
            // Check if coordinates have been replaced (they look like they have!)
            if (firebaseConfig.apiKey.startsWith("AIza")) {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                isFirebaseInitialized = true;
                console.log("Firebase initialized successfully");
            }
        } catch (e) {
            console.error("Firebase initialization failed:", e);
        }



        window.openLeaderboard = async function () {
            document.getElementById('leaderboard-modal').style.display = 'flex';
            document.getElementById('leaderboard-loading').style.display = 'block';
            document.getElementById('leaderboard-table').style.display = 'none';
            isPaused = true;

            if (!isFirebaseInitialized) {
                // Show mock data if Firebase is not setup
                setTimeout(() => {
                    const mockData = [
                        { name: "Loki", score: 15400, realm: 9 },
                        { name: "Sylvie", score: 12200, realm: 7 },
                        { name: "Mobius", score: 8500, realm: 5 },
                        { name: "Thor", score: 5000, realm: 3 },
                        { name: "Odin", score: 3000, realm: 2 }
                    ];
                    const body = document.getElementById('leaderboard-body');
                    body.innerHTML = mockData.map(d => `<tr><td>${d.name}</td><td>${d.score}</td><td>${d.realm}</td></tr>`).join('');
                    document.getElementById('leaderboard-loading').style.display = 'none';
                    document.getElementById('leaderboard-table').style.display = 'table';
                }, 800);
                return;
            }

            try {
                const q = query(collection(db, "leaderboard"), orderBy("score", "desc"), limit(10));
                const querySnapshot = await getDocs(q);
                const body = document.getElementById('leaderboard-body');
                body.innerHTML = "";

                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    const row = `<tr>
                        <td>${data.name}</td>
                        <td>${data.score}</td>
                        <td>${data.realm}</td>
                    </tr>`;
                    body.innerHTML += row;
                });

                document.getElementById('leaderboard-loading').style.display = 'none';
                document.getElementById('leaderboard-table').style.display = 'table';
            } catch (e) {
                console.error("Error fetching leaderboard:", e);
                document.getElementById('leaderboard-loading').textContent = "Failed to load the Hall of Heroes.";
            }
        };

        window.closeLeaderboard = function () {
            document.getElementById('leaderboard-modal').style.display = 'none';
            isPaused = false;
            render();
        };

        window.submitScore = async function () {
            if (!isFirebaseInitialized) {
                showNotification("Firebase not configured. Score not saved locally.");
                document.getElementById('score-submit-container').style.display = 'none';
                openLeaderboard();
                return;
            }

            const name = document.getElementById('player-name').value.trim() || "Anonymous Hero";
            const score = player.totalScore;
            const realm = level;

            const btn = document.getElementById('submit-score-btn');
            btn.disabled = true;
            btn.textContent = "Recording...";

            try {
                await addDoc(collection(db, "leaderboard"), {
                    name: name,
                    score: score,
                    realm: realm,
                    timestamp: new Date()
                });
                showNotification("Your legend has been recorded!");
                document.getElementById('score-submit-container').style.display = 'none';
                openLeaderboard();
            } catch (e) {
                console.error("Error submitting score:", e);
                showNotification("The Norns rejected your score.");
                btn.disabled = false;
                btn.textContent = "Try Again";
            }
        };

        var currentGateAnswer = "";
        var currentGateHint = "";
        const music = document.getElementById('bg-music');

        function playMusicWithRetry() {
            music.play().catch(e => {
                console.log("Audio play failed, retrying...", e);
                setTimeout(playMusicWithRetry, 100);
            });
        }

        playMusicWithRetry();

        function showNotification(text) {
            const container = document.getElementById('notification-container');
            const note = document.createElement('div');
            note.className = 'notification';
            note.textContent = text;
            container.appendChild(note);

            setTimeout(() => {
                note.style.animation = 'fadeOut 1s forwards';
                setTimeout(() => note.remove(), 1000);
            }, 3000);
        }

        let canvasShake = { x: 0, y: 0, duration: 0 };

        function triggerShake(duration = 20) {
            canvasShake.duration = duration;
        }

        function animateValue(id, start, end, duration) {
            if (start === end) return;
            const obj = document.getElementById(id);
            const range = end - start;
            let startTime = null;

            function step(timestamp) {
                if (!startTime) startTime = timestamp;
                const progress = Math.min((timestamp - startTime) / duration, 1);
                obj.textContent = Math.floor(progress * range + start);
                if (progress < 1) {
                    window.requestAnimationFrame(step);
                } else {
                    obj.textContent = end;
                }
            }
            window.requestAnimationFrame(step);
        }

        function drawVignette() {
            const vignette = ctx.createRadialGradient(
                player.x * TILE_SIZE + TILE_SIZE / 2, player.y * TILE_SIZE + TILE_SIZE / 2, TILE_SIZE * 2,
                player.x * TILE_SIZE + TILE_SIZE / 2, player.y * TILE_SIZE + TILE_SIZE / 2, TILE_SIZE * 8
            );
            vignette.addColorStop(0, 'rgba(0,0,0,0)');
            vignette.addColorStop(1, 'rgba(0,0,0,0.85)');
            ctx.fillStyle = vignette;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        async function triggerLevelTransition(realmName) {
            // Fetch realm descriptions
            let realmDesc = "";
            try {
                const response = await fetch('questions/levels.json');
                const descriptions = await response.json();
                realmDesc = descriptions[realmName] || "";
            } catch (err) {
                console.error("Failed to load realm descriptions:", err);
            }

            return new Promise((resolve) => {
                const overlay = document.getElementById('transition-overlay');
                const realmText = document.getElementById('transition-realm-name');
                const descText = document.getElementById('transition-realm-desc');

                realmText.textContent = realmName || `Realm ${level}`;
                descText.textContent = realmDesc;

                overlay.style.display = 'flex';
                setTimeout(() => overlay.classList.add('active'), 50);

                // Extended time to read the description
                setTimeout(() => {
                    overlay.classList.remove('active');
                    setTimeout(() => {
                        overlay.style.display = 'none';
                        resolve();
                    }, 800);
                }, 4000); // 4 seconds instead of 2
            });
        }

        const realms = ["Midgard", "Alfheim", "Asgard", "Jotunheim", "Vanaheim", "Nidavellir", "Muspelheim", "Niflheim", "Helheim"];

        async function nextLevel() {
            const realmName = realms[(level) % realms.length];

            isPaused = true;
            await triggerLevelTransition(realmName);
            level++;
            startLevel();
            isPaused = false;
        }

        function showDeathScreen(text) {
            isGameOver = true;
            isPaused = true;
            const screen = document.getElementById('death-screen');
            const msgEl = document.getElementById('death-msg');
            msgEl.textContent = text;
            screen.style.display = 'flex';
            screen.style.animation = 'fadeIn 2s forwards';

            // Show score submission
            document.getElementById('final-score').textContent = player.totalScore;
            document.getElementById('score-submit-container').style.display = 'flex';

            // Pre-fill name from localStorage
            const savedName = localStorage.getItem('loki_player_name') || "";
            document.getElementById('player-name').value = savedName;

            // Stop background music
            music.pause();
            const goMusic = document.getElementById('gameover-music');
            if (goMusic && goMusic.paused) {
                goMusic.currentTime = 0;
                goMusic.play().catch(e => console.log("Game over music failed to play:", e));
            }
        }
        // --- GAME SETUP & CONFIG ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');


        const TILE_SIZE = 48; // Increased size for more detail
        const wallChar = '#';
        const floorChar = ' ';
        const exitChar = '>';

        const WALL_COLOR = '#0a210f'; // Deep jungle green
        const FLOOR_COLOR = '#051208'; // Almost black green
        const RUNE_GLOW = '#d4af37';

        // --- ASSET MANAGEMENT ---
        const assets = {
            heroIdleWeapon: document.getElementById('hero-idle-weapon'),
            heroIdleNoWeapon: document.getElementById('hero-idle-no-weapon'),
            heroRun: [
                document.getElementById('hero-run-1'),
                document.getElementById('hero-run-2'),
                document.getElementById('hero-run-3'),
                document.getElementById('hero-run-4')
            ],
            enemy: document.getElementById('enemy-img'),
            enemy2: document.getElementById('enemy2-img'),
            enemy3: document.getElementById('enemy3-img'),
            coin: document.getElementById('coin-img'),
            weapon: document.getElementById('weapon-img'),
            potion: document.getElementById('potion-img'),
            spaceStone: null, // Drawing logic fallback
            portal: null
        };

        // --- GAME STATE ---
        let level = 1;
        let map = [];
        let player = {};
        let enemies = [];
        let collectibles = [];
        let portals = []; // Placed portals
        let mazeWidth, mazeHeight;
        let isGameOver = false;
        let isGridView = false; // Grid mode state

        // Animation state
        let heroAnimationFrame = 0;
        let isMoving = false;
        let moveAnimTimer = null;

        // --- MAZE GENERATION (Prim's Algorithm) ---
        function generateMaze(width, height) {
            width = width % 2 === 0 ? width + 1 : width;
            height = height % 2 === 0 ? height + 1 : height;
            mazeWidth = width;
            mazeHeight = height;

            let maze = Array(height).fill(null).map(() => Array(width).fill(wallChar));
            let startX = 1, startY = 1;
            maze[startY][startX] = floorChar;
            let walls = [];
            walls.push({ x: startX + 1, y: startY, fromX: startX, fromY: startY });
            walls.push({ x: startX - 1, y: startY, fromX: startX, fromY: startY });
            walls.push({ x: startX, y: startY + 1, fromX: startX, fromY: startY });
            walls.push({ x: startX, y: startY - 1, fromX: startX, fromY: startY });

            while (walls.length > 0) {
                let wallIndex = Math.floor(Math.random() * walls.length);
                let wall = walls[wallIndex];
                let oppositeX = wall.x + (wall.x - wall.fromX);
                let oppositeY = wall.y + (wall.y - wall.fromY);
                if (oppositeY > 0 && oppositeY < height - 1 && oppositeX > 0 && oppositeX < width - 1 && maze[oppositeY][oppositeX] === wallChar) {
                    maze[wall.y][wall.x] = floorChar;
                    maze[oppositeY][oppositeX] = floorChar;
                    if (oppositeY > 1) walls.push({ x: oppositeX, y: oppositeY - 1, fromX: oppositeX, fromY: oppositeY });
                    if (oppositeY < height - 2) walls.push({ x: oppositeX, y: oppositeY + 1, fromX: oppositeX, fromY: oppositeY });
                    if (oppositeX > 1) walls.push({ x: oppositeX - 1, y: oppositeY, fromX: oppositeX, fromY: oppositeY });
                    if (oppositeX < width - 2) walls.push({ x: oppositeX + 1, y: oppositeY, fromX: oppositeX, fromY: oppositeY });
                }
                walls.splice(wallIndex, 1);
            }
            maze[height - 2][width - 2] = exitChar;
            return maze.map(row => row.join(''));
        }

        // --- ENTITY PLACEMENT ---
        function populateMaze() {
            enemies = [];
            collectibles = [];
            let emptyTiles = [];
            for (let y = 0; y < mazeHeight; y++) {
                for (let x = 0; x < mazeWidth; x++) {
                    if (map[y][x] === floorChar && !(x === 1 && y === 1)) {
                        emptyTiles.push({ x, y });
                    }
                }
            }
            emptyTiles.sort(() => Math.random() - 0.5);

            // More enemies!
            const baseEnemyCount = 2 + (level * 2);
            for (let i = 0; i < baseEnemyCount && emptyTiles.length > 0; i++) {
                const pos = emptyTiles.pop();

                // Determine Enemy Type and Level first
                let enemyLevel = 1;
                let type = 'normal';
                let img = 'enemy.png';

                const roll = Math.random();
                if (level >= 3 && roll > 0.85) {
                    enemyLevel = 3;
                    type = 'boss';
                    img = 'enemy3.png';
                } else if (level >= 2 && roll > 0.6) {
                    enemyLevel = 2;
                    type = 'elite';
                    img = 'enemy2.png';
                }

                // Stats based on fixed level
                let hp = 50 + (enemyLevel * 25);
                let dmg = 5 + (enemyLevel * 5);

                if (type === 'boss') {
                    hp *= 2; // Extra beefy
                    dmg *= 1.5;
                } else if (type === 'elite') {
                    hp *= 1.3;
                    dmg *= 1.2;
                }

                enemies.push({
                    x: pos.x,
                    y: pos.y,
                    health: Math.floor(hp),
                    maxHealth: Math.floor(hp),
                    damage: Math.floor(dmg),
                    level: enemyLevel,
                    confused: false,
                    type: type,
                    img: img,
                    id: Math.random().toString(36).substr(2, 9)
                });
            }

            const coinCount = 5 + (level * 2);
            for (let i = 0; i < coinCount && emptyTiles.length > 0; i++) {
                const pos = emptyTiles.pop();
                collectibles.push({ x: pos.x, y: pos.y, type: 'coin' });
            }

            if (emptyTiles.length > 0) {
                const pos = emptyTiles.pop();
                collectibles.push({ x: pos.x, y: pos.y, type: 'weapon' });
            }

            // Health Potion Spawn (30% chance)
            if (Math.random() < 0.3 && emptyTiles.length > 0) {
                const pos = emptyTiles.pop();
                collectibles.push({ x: pos.x, y: pos.y, type: 'potion' });
            }

            // Space Stone Fragments (3 fragments per level, but harder on Level 1)
            const stonesToSpawn = (level === 1) ? 1 : 3;
            for (let i = 0; i < stonesToSpawn && emptyTiles.length > 0; i++) {
                const pos = emptyTiles.pop();
                collectibles.push({ x: pos.x, y: pos.y, type: 'spaceStone' });
            }
        }

        // --- RENDER & UI ---
        function render() {
            try {
                if (!map || map.length === 0) return;

                canvas.width = mazeWidth * TILE_SIZE;
                canvas.height = mazeHeight * TILE_SIZE;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.save(); // Save state for whole render pass

                // Reset context state to defaults
                ctx.textAlign = 'start';
                ctx.textBaseline = 'alphabetic';
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1.0;

                // Apply Screen Shake
                if (canvasShake.duration > 0) {
                    const intensity = 5;
                    canvasShake.x = (Math.random() - 0.5) * intensity;
                    canvasShake.y = (Math.random() - 0.5) * intensity;
                    ctx.translate(canvasShake.x, canvasShake.y);
                    canvasShake.duration--;
                }

                // Draw Map
                for (let y = 0; y < map.length; y++) {
                    for (let x = 0; x < map[y].length; x++) {
                        const tileX = x * TILE_SIZE;
                        const tileY = y * TILE_SIZE;
                        if (map[y][x] === wallChar) {
                            // Wall Gradient
                            const grad = ctx.createLinearGradient(tileX, tileY, tileX + TILE_SIZE, tileY + TILE_SIZE);
                            grad.addColorStop(0, WALL_COLOR);
                            grad.addColorStop(1, '#051208');
                            ctx.fillStyle = grad;
                            ctx.fillRect(tileX, tileY, TILE_SIZE, TILE_SIZE);
                            ctx.strokeStyle = '#0e2e15';
                            ctx.strokeRect(tileX + 4, tileY + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                        } else {
                            ctx.fillStyle = FLOOR_COLOR;
                            ctx.fillRect(tileX, tileY, TILE_SIZE, TILE_SIZE);
                            if (map[y][x] === exitChar) {
                                ctx.save();
                                ctx.fillStyle = '#C0C0C0';
                                ctx.font = `bold ${TILE_SIZE * 0.8}px 'Cinzel'`;
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.shadowBlur = 10;
                                ctx.shadowColor = '#00ff41';
                                // Animated Exit
                                const pulseOffset = Math.sin(Date.now() / 300) * 5;
                                ctx.fillText('Œ©', tileX + TILE_SIZE / 2, tileY + TILE_SIZE / 2 + pulseOffset);
                                ctx.restore();
                            }
                        }
                    }
                }

                // Draw Assets
                collectibles.forEach(c => {
                    if (assets[c.type]) {
                        ctx.drawImage(assets[c.type], c.x * TILE_SIZE, c.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    } else if (c.type === 'spaceStone') {
                        // Drawing logic for Space Stone
                        ctx.save();
                        ctx.fillStyle = "#00d4ff";
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = "#00d4ff";
                        const centerX = c.x * TILE_SIZE + TILE_SIZE / 2;
                        const centerY = c.y * TILE_SIZE + TILE_SIZE / 2;
                        // Animated Rotation
                        const angle = Date.now() / 500;
                        ctx.translate(centerX, centerY);
                        ctx.rotate(angle);
                        ctx.beginPath();
                        ctx.moveTo(0, -TILE_SIZE / 4);
                        ctx.lineTo(TILE_SIZE / 4, 0);
                        ctx.lineTo(0, TILE_SIZE / 4);
                        ctx.lineTo(-TILE_SIZE / 4, 0);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    }
                });

                // Draw Portals
                portals.forEach(p => {
                    ctx.save();
                    ctx.strokeStyle = "#00ff41";
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 20 + Math.sin(Date.now() / 200) * 10;
                    ctx.shadowColor = "#00ff41";
                    const centerX = p.x * TILE_SIZE + TILE_SIZE / 2;
                    const centerY = p.y * TILE_SIZE + TILE_SIZE / 2;
                    const scale = 1 + Math.sin(Date.now() / 400) * 0.1;
                    ctx.beginPath();
                    ctx.ellipse(centerX, centerY, (TILE_SIZE / 3) * scale, (TILE_SIZE / 2) * scale, Math.sin(Date.now() / 1000) * 0.2, 0, Math.PI * 2);
                    ctx.stroke();

                    // Inner glow
                    ctx.fillStyle = "rgba(0, 255, 65, 0.2)";
                    ctx.fill();
                    ctx.restore();
                });

                enemies.forEach(e => {
                    let sprite = assets.enemy;
                    if (e.type === 'elite') sprite = assets.enemy2;
                    if (e.type === 'boss') sprite = assets.enemy3;

                    if (sprite && sprite.complete) {
                        ctx.drawImage(sprite, e.x * TILE_SIZE, e.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    } else {
                        // Fallback if sprite not loaded
                        ctx.fillStyle = "red";
                        ctx.fillRect(e.x * TILE_SIZE, e.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }

                    // HP Bar
                    ctx.fillStyle = "rgba(0,0,0,0.5)";
                    ctx.fillRect(e.x * TILE_SIZE, e.y * TILE_SIZE - 10, TILE_SIZE, 5);
                    ctx.fillStyle = e.confused ? "#00ff41" : "#ff0000";
                    if (e.type === 'boss') ctx.fillStyle = "#aa00ff";
                    ctx.fillRect(e.x * TILE_SIZE, e.y * TILE_SIZE - 10, (e.health / e.maxHealth) * TILE_SIZE, 5);

                    ctx.fillStyle = "white";
                    ctx.font = "10px Cinzel";
                    ctx.fillText(`Lvl ${e.level}`, e.x * TILE_SIZE, e.y * TILE_SIZE - 15);

                    if (e.confused) {
                        ctx.fillStyle = "#00ff41";
                        ctx.fillText("?", e.x * TILE_SIZE + TILE_SIZE / 2, e.y * TILE_SIZE + TILE_SIZE / 2);
                    }
                });

                let heroSprite;
                if (isMoving) {
                    heroSprite = assets.heroRun[heroAnimationFrame];
                } else {
                    heroSprite = player.hasWeapon ? assets.heroIdleWeapon : assets.heroIdleNoWeapon;
                }

                if (!heroSprite) heroSprite = assets.heroIdleNoWeapon;

                if (heroSprite && heroSprite.complete) {
                    ctx.drawImage(heroSprite, player.x * TILE_SIZE, player.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                } else {
                    console.warn("Hero sprite not ready for level", level, "at", player.x, player.y);
                    // Draw a placeholder if image is failing
                    ctx.fillStyle = "gold";
                    ctx.beginPath();
                    ctx.arc(player.x * TILE_SIZE + TILE_SIZE / 2, player.y * TILE_SIZE + TILE_SIZE / 2, TILE_SIZE / 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Final UI Overlays (Restored from shake/camera)
                ctx.restore();

                // drawVignette(); // Call this here for "blindness" or "darkness" levels if needed

                const realmName = realms[(level - 1) % realms.length];
                document.getElementById('level-text').textContent = `${realmName} (${level})`;
                document.getElementById('health-text').textContent = player.health;

                const oldScore = parseInt(document.getElementById('score-text').textContent);
                if (oldScore !== (player.totalScore || 0)) {
                    animateValue('score-text', oldScore, player.totalScore || 0, 500);
                }

                let weaponVal = '0';
                if (player.hasWeapon) {
                    weaponVal = player.weaponDurability;
                    document.getElementById('weapon-text').classList.add('ready-pulse');
                    document.getElementById('weapon-text').style.color = "#00ff41";
                } else {
                    document.getElementById('weapon-text').classList.remove('ready-pulse');
                    document.getElementById('weapon-text').style.color = "#ff4141";
                }
                document.getElementById('weapon-text').textContent = weaponVal;

                const mischiefEl = document.getElementById('mischief-status');
                if (mischiefEl) {
                    mischiefEl.textContent = mischiefUsed ? "0" : "1";
                    if (mischiefUsed) {
                        mischiefEl.style.color = "#ff4141";
                        mischiefEl.classList.remove('ready-pulse');
                    } else {
                        mischiefEl.style.color = "#00ff41";
                        mischiefEl.classList.add('ready-pulse');
                    }
                }

                // Update New HUD items
                document.getElementById('stone-text').textContent = player.spaceStones || 0;
                document.getElementById('portal-text').textContent = player.portals || 0;

                // Update Side HUD
                const viewTextSide = document.getElementById('view-text-side');
                if (viewTextSide) {
                    viewTextSide.textContent = isGridView ? "Grid" : "Standard";
                }
            } catch (err) {
                console.error("Render failure on level", level, ":", err);
            }
        }

        // --- ENEMY AI ---
        function processEnemyTurns() {
            enemies.forEach(enemy => {
                if (enemy.confused) {
                    // Confused enemies might skip turn or move randomly even more
                    if (Math.random() > 0.5) return;
                }

                const dx = Math.abs(player.x - enemy.x);
                const dy = Math.abs(player.y - enemy.y);

                if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) {
                    if (enemy.level === 1) {
                        // Level 1 enemies only attack in 3D view
                        return;
                    }
                    if (!enemy.confused) {
                        player.health -= enemy.damage;
                        triggerShake(15);
                    } else {
                        // Confused enemies might skip turn or move randomly even more
                        if (Math.random() > 0.5) {
                            player.health -= Math.floor(enemy.damage / 2);
                            triggerShake(8);
                        }
                    }
                    return;
                }

                const move = Math.floor(Math.random() * 5);
                let newX = enemy.x;
                let newY = enemy.y;

                if (move === 1) newY--; else if (move === 2) newY++;
                else if (move === 3) newX--; else if (move === 4) newX++;

                const isWall = map[newY] && map[newY][newX] === wallChar;
                const isPlayer = newX === player.x && newY === player.y;
                const isOtherEnemy = enemies.some(e => e !== enemy && e.x === newX && e.y === newY);

                if (map[newY] && !isWall && !isPlayer && !isOtherEnemy) {
                    enemy.x = newX;
                    enemy.y = newY;
                }
            });
        }

        // --- MISCHIEF SYSTEM ---
        let currentTarget = null;
        let mischiefUsed = false;

        function openMischief() {
            if (mischiefUsed) {
                showNotification("Your trickery is exhausted for this realm. Wait for the next.");
                return;
            }

            // Find closest enemy
            let closest = null;
            let minDist = Infinity;
            enemies.forEach(e => {
                const dist = Math.sqrt(Math.pow(player.x - e.x, 2) + Math.pow(player.y - e.y, 2));
                if (dist < minDist && dist < 3) {
                    minDist = dist;
                    closest = e;
                }
            });

            if (!closest) {
                showNotification("No enemies nearby to trick!");
                return;
            }

            currentTarget = closest;

            // FIX STARTS HERE:
            const modal = document.getElementById('mischief-modal');
            if (modal) {
                modal.style.display = 'flex';
                document.getElementById('mischief-target-info').textContent = `Target: Lvl ${currentTarget.level} Foe`;
                document.getElementById('mischief-input').value = '';
                document.getElementById('mischief-result').textContent = '';
                isPaused = true;
            } else {
                console.error("Could not find mischief-modal element!");
            }
        }

        window.closeMischief = function () {
            document.getElementById('mischief-modal').style.display = 'none';
            isPaused = false;
            render();
        }

        window.submitMischief = async function () {
            const text = document.getElementById('mischief-input').value;
            if (!text.trim()) return;

            const resultEl = document.getElementById('mischief-result');
            resultEl.textContent = "Judging your deception...";

            try {
                const res = await fetch(
                    "https://loki.veerbajaj11.workers.dev/mischief",
                    {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            text,
                            level,
                            enemyLevel: currentTarget.level
                        })
                    }
                );

                const data = await res.json();
                console.log("Mischief Response:", data);
                if (data.success) {
                    resultEl.textContent = "Loki cackles - your mischief succeeds!";
                    resultEl.style.color = "#00ff41";
                    currentTarget.confused = true;
                    currentTarget.damage = Math.max(1, Math.floor(currentTarget.damage * 0.6));
                } else {
                    resultEl.textContent = "Loki sees through your ruse... failure.";
                    resultEl.style.color = "#ff4141";
                }

                mischiefUsed = true;

                setTimeout(() => {
                    closeMischief();
                    processEnemyTurns();
                    render();
                }, 1500);

            } catch (err) {
                resultEl.textContent = "The trick fizzles in chaos...";
                resultEl.style.color = "#ff4141";
                console.error(err);
            }
        }
        window.openCredits = function () {
            document.getElementById('credits-modal').style.display = 'flex';
            isPaused = true;
        }

        window.closeCredits = function () {
            document.getElementById('credits-modal').style.display = 'none';
            isPaused = false;
            render();
        }

        let isPaused = false;

        // --- COMBAT SYSTEM (3D) ---
        let combatEnemyIndex = -1;

        window.addEventListener('message', (event) => {
            if (event.data.type === 'fight-result') {
                endCombat(event.data.won, event.data.playerHP);
            }
            if (event.data.type === 'cheat-health') {
                player.health = event.data.health;
                render();
            }
        });

        function startCombat(enemyIndex) {
            if (player.weaponDurability <= 0) return;

            const enemy = enemies[enemyIndex];
            combatEnemyIndex = enemyIndex;

            document.getElementById('fight-modal').style.display = 'flex';
            const frame = document.getElementById('fight-frame');

            // Pass stats to 3D fight
            // current health, damage, and image params
            frame.src = `3D/index.html?hp=${enemy.health}&dmg=${enemy.damage}&img=${enemy.img}&playerHP=${player.health}`;

            // Ensure focus for interaction
            frame.onload = () => {
                frame.contentWindow.focus();
            };

            isPaused = true;
        }


        function endCombat(won, remainingHP) {
            document.getElementById('fight-modal').style.display = 'none';
            document.getElementById('fight-frame').src = ''; // Unload to stop loops
            isPaused = false;

            if (combatEnemyIndex !== -1 && won) {
                const enemy = enemies[combatEnemyIndex];
                // Victory logic
                enemies.splice(combatEnemyIndex, 1);

                // Reward based on enemy type
                let reward = 10;
                let scoreGain = 100;
                if (enemy.type === 'elite') { reward = 25; scoreGain = 250; }
                if (enemy.type === 'boss') { reward = 100; scoreGain = 1000; }

                player.coins += reward;
                player.totalScore += scoreGain;
                showNotification(`Foe Vanquished! +${scoreGain} Score`);

                player.weaponDurability--;
                if (player.weaponDurability <= 0) player.hasWeapon = false;

                processEnemyTurns();
            } else if (combatEnemyIndex !== -1 && !won) {
                player.health = 0;
                playCutscene('scene/death.mp4', () => {
                    showDeathScreen("You fell in battle. The Valkyries did not come.");
                });
            }

            if (remainingHP !== undefined) {
                player.health = remainingHP;
            }
            combatEnemyIndex = -1;
            render();
        }

        // --- GAME CONTROL ---
        function startLevel() {
            console.log("Starting Level:", level);
            isGameOver = false;
            mischiefUsed = false;
            const width = 13 + (level * 2);
            const height = 9 + (level * 2);
            console.log("Maze dimensions:", width, "x", height);

            player = {
                x: 1, y: 1,
                health: player.health || 100,
                coins: player.coins || 0,
                totalScore: player.totalScore || 0,
                hasWeapon: player.hasWeapon || false,
                weaponDurability: player.weaponDurability || 0,
                spaceStones: player.spaceStones || 0,
                portals: player.portals || 0
            };

            portals = []; // Clear portals each level
            map = generateMaze(width, height);
            populateMaze();
            render();
            console.log("Level", level, "initialized. Player at:", player.x, player.y);
        }

        document.addEventListener('keydown', function (event) {
            if (isGameOver || isPaused) return;

            let newX = player.x;
            let newY = player.y;
            let playerAction = false;

            const key = event.key.toLowerCase();
            if (key === 'w') { newY--; playerAction = true; }
            else if (key === 's') { newY++; playerAction = true; }
            else if (key === 'a') { newX--; playerAction = true; }
            else if (key === 'd') { newX++; playerAction = true; }
            else if (key === 'p') { // Place Portal
                if (player.portals > 0) {
                    player.portals--;
                    portals.push({ x: player.x, y: player.y });
                    showNotification("Portal Opened! Enter to skip realms.");
                } else {
                    showNotification("Collect 3 Space Stone fragments to forge a portal!");
                }
                render();
                return;
            }
            else if (key === 'v') { // Toggle Grid Mode
                toggleGridView();
                return;
            }
            else if (key === '1') { // Combat
                if (player.hasWeapon && player.weaponDurability > 0) {
                    // Find closest valid enemy
                    let targetIdx = -1;
                    for (let i = 0; i < enemies.length; i++) {
                        const enemy = enemies[i];
                        const dx = Math.abs(player.x - enemy.x);
                        const dy = Math.abs(player.y - enemy.y);
                        if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) {
                            targetIdx = i;
                            break;
                        }
                    }

                    if (targetIdx !== -1) {
                        startCombat(targetIdx);
                        return; // Wait for async fight
                    }
                }
            } else if (key === '2') { // Mischief
                openMischief();
            } else {
                return;
            }
            event.preventDefault();

            const isEnemy = enemies.some(e => e.x === newX && e.y === newY);
            if (map[newY] && map[newY][newX] !== wallChar && !isEnemy) {
                player.x = newX;
                player.y = newY;

                // Handle running animation
                if (playerAction && (key === 'w' || key === 's' || key === 'a' || key === 'd')) {
                    isMoving = true;
                    if (moveAnimTimer) clearInterval(moveAnimTimer);

                    let frameCount = 0;
                    moveAnimTimer = setInterval(() => {
                        heroAnimationFrame = (heroAnimationFrame + 1) % 4;
                        render();
                        frameCount++;
                        if (frameCount > 8) { // Animation duration
                            clearInterval(moveAnimTimer);
                            isMoving = false;
                            heroAnimationFrame = 0;
                            render();
                        }
                    }, 50); // Fast succession
                }
            }

            collectibles.forEach((c, index) => {
                if (player.x === c.x && player.y === c.y) {
                    if (c.type === 'coin') {
                        player.totalScore += 100;
                    }
                    if (c.type === 'weapon') {
                        player.hasWeapon = true;
                        player.weaponDurability = 10 + level;
                        player.totalScore += 50;
                    }
                    if (c.type === 'potion') {
                        player.health = 100;
                        player.totalScore += 25;
                        playCutscene('scene/health.mp4');
                    }
                    if (c.type === 'spaceStone') {
                        player.spaceStones++;
                        player.totalScore += 50;
                        showNotification(`Space Stone Fragment Collected! (${player.spaceStones}/3)`);
                        if (player.spaceStones >= 3) {
                            player.spaceStones -= 3;
                            player.portals++;
                            showNotification("Tesseract Fragment Forged! Portal Ready (Press P)");
                        }
                    }
                    collectibles.splice(index, 1);
                }
            });

            // Check for Portal interaction
            portals.forEach((p, index) => {
                if (player.x === p.x && player.y === p.y) {
                    showNotification("Entering the Void... Skipping 5 Realms!");
                    portals.splice(index, 1);
                    setTimeout(async () => {
                        level += 4; // Add 4 here because nextLevel adds 1
                        await nextLevel();
                    }, 500);
                }
            });

            // Inside your document.addEventListener('keydown', ...) 
            if (map[player.y][player.x] === exitChar) {
                // Instead of level++ and startLevel(), trigger the question
                askGatekeeperQuestion();
                return;
            }
            if (playerAction) {
                processEnemyTurns();
            }


            async function askGatekeeperQuestion() {
                isPaused = true;
                const modal = document.getElementById('gatekeeper-modal');
                const questionEl = document.getElementById('gate-question-text');
                const optionsContainer = document.getElementById('gate-options-container');
                const feedbackEl = document.getElementById('gate-feedback');
                const hintText = document.getElementById('gate-hint-text');
                const hintBtn = document.getElementById('hint-btn');

                feedbackEl.textContent = "";
                hintText.style.display = 'none';
                hintBtn.style.display = 'inline-block';
                optionsContainer.innerHTML = "Loading choices...";
                modal.style.display = 'flex';

                try {
                    const response = await fetch('questions/list.json');
                    const questions = await response.json();

                    if (questions && questions.length > 0) {
                        const randomQ = questions[Math.floor(Math.random() * questions.length)];
                        questionEl.textContent = randomQ.question;
                        currentGateAnswer = randomQ.answer;
                        currentGateHint = randomQ.hint;

                        optionsContainer.innerHTML = "";
                        randomQ.options.forEach(option => {
                            const btn = document.createElement('button');
                            btn.textContent = option;
                            btn.className = "gate-option-btn"; // Add a class for CSS styling
                            btn.style = "padding: 10px; background: #111; color: white; border: 1px solid var(--gold); cursor: pointer; font-family: 'Cinzel';";
                            btn.onclick = () => checkGateAnswer(option);
                            optionsContainer.appendChild(btn);
                        });
                    }
                } catch (e) {
                    console.error("Error:", e);
                    questionEl.textContent = "Fallout: Who is the God of Mischief?";
                    currentGateAnswer = "Loki";
                    currentGateHint = "It's the name of this game.";
                    optionsContainer.innerHTML = `<button onclick="checkGateAnswer('Loki')">Loki</button>`;
                }
            }

            window.checkGateAnswer = function (selectedOption) {
                const feedbackEl = document.getElementById('gate-feedback');

                if (selectedOption === currentGateAnswer) {
                    feedbackEl.textContent = "Correct. You may pass.";
                    feedbackEl.style.color = "#00ff41";
                    player.totalScore += 500;
                    showNotification("Level Cleared! +500 Score");
                    setTimeout(async () => {
                        document.getElementById('gatekeeper-modal').style.display = 'none';
                        await nextLevel();
                    }, 1000);
                } else {
                    feedbackEl.textContent = "Incorrect. The Bifrost remains closed.";
                    feedbackEl.style.color = "#ff4141";
                    player.health -= 5;
                    document.getElementById('health-text').textContent = player.health;
                    if (player.health <= 0) {
                        player.health = 0;
                        playCutscene('scene/death.mp4', () => {
                            showDeathScreen("The Gatekeeper's judgement was final. You are no more.");
                        });
                    }
                }
            };

            window.buyHint = function () {
                const hintText = document.getElementById('gate-hint-text');
                const hintBtn = document.getElementById('hint-btn');

                if (player.totalScore >= 150) {
                    player.totalScore -= 150;
                    document.getElementById('score-text').textContent = player.totalScore;
                    hintText.textContent = "Hint: " + currentGateHint;
                    hintText.style.display = 'block';
                    hintBtn.style.display = 'none';
                } else {
                    showNotification("You do not have enough Runes! (Need 150)");
                }
            };

            if (player.health <= 0) {
                player.health = 0;
                playCutscene('scene/death.mp4', () => {
                    showDeathScreen("Your life force fades. Ragnarok has come for you.");
                });
            }

            render();
        });

        function toggleGridView() {
            isGridView = !isGridView;
            const canvasEl = document.getElementById('gameCanvas');
            const viewText = document.getElementById('view-text-side');

            if (isGridView) {
                canvasEl.classList.add('grid-mode');
                if (viewText) viewText.textContent = "Grid";
                showNotification("Grid Mode / Mini-Map Enabled");
            } else {
                canvasEl.classList.remove('grid-mode');
                if (viewText) viewText.textContent = "Standard";
                showNotification("Standard View Enabled");
            }
            render();
        }

        // --- SECRET CHEAT CODES ---
        let cheatBuffer = "";
        const secretLevel = "banana";
        const secretPotion = "ballers"; // New code

        document.addEventListener('keydown', (e) => {
            cheatBuffer += e.key.toLowerCase();

            // Keep the buffer at a reasonable length
            if (cheatBuffer.length > 10) {
                cheatBuffer = cheatBuffer.slice(-10);
            }

            // Existing Level Skip
            if (cheatBuffer.endsWith(secretLevel)) {
                console.log("üçå Secret Activated: Moving to next level!");
                level++;
                startLevel();
                cheatBuffer = "";
            }

            // NEW: Potion Spawn
            if (cheatBuffer.endsWith(secretPotion)) {
                console.log("üíé Potion Summoned!");
                spawnPotionNextToPlayer();
                cheatBuffer = "";
            }
        });

        // --- CONSOLE CHEATS ---
        // Access these via the browser's Developer Console (F12)
        window.addRunes = (amount) => {
            if (typeof amount !== 'number') return "Please provide a number (e.g., addRunes(1000))";
            player.totalScore = (player.totalScore || 0) + amount;
            render();
            showNotification(`Runes Granted: +${amount}`);
            return `New Balance: ${player.totalScore} Runes`;
        };

        window.setRunes = (amount) => {
            if (typeof amount !== 'number') return "Please provide a number (e.g., setRunes(5000))";
            player.totalScore = amount;
            render();
            return `Projected Balance: ${player.totalScore} Runes`;
        };


        function spawnPotionNextToPlayer() {
            // Look at adjacent tiles (Up, Down, Left, Right)
            const directions = [
                { x: 0, y: -1 }, { x: 0, y: 1 },
                { x: -1, y: 0 }, { x: 1, y: 0 }
            ];

            for (let dir of directions) {
                let targetX = player.x + dir.x;
                let targetY = player.y + dir.y;

                // Check if the tile is a floor and doesn't already have a collectible
                const isFloor = map[targetY] && map[targetY][targetX] === floorChar;
                const isOccupied = collectibles.some(c => c.x === targetX && c.y === targetY);
                const hasEnemy = enemies.some(e => e.x === targetX && e.y === targetY);

                if (isFloor && !isOccupied && !hasEnemy) {
                    collectibles.push({ x: targetX, y: targetY, type: 'potion' });
                    render(); // Refresh the canvas to show the potion
                    return; // Exit after spawning one
                }
            }
            showNotification("No room to spawn a potion here!");
        }

        // --- CUTSCENE LOGIC ---
        function playCutscene(videoPath, callback) {
            const modal = document.getElementById('cutscene-modal');
            const video = document.getElementById('cutscene-video');

            if (music) music.pause();

            isPaused = true;
            modal.style.display = 'flex';
            video.src = videoPath;

            if (videoPath.includes('death.mp4')) {
                const goMusic = document.getElementById('gameover-music');
                if (goMusic) {
                    goMusic.currentTime = 0;
                    goMusic.play().catch(e => console.log("Game over music failed to play during cutscene:", e));
                }
            }

            video.play().catch(e => {
                console.log("Autoplay prevented, trying mute", e);
                video.muted = true;
                video.play();
            });

            video.onended = () => {
                modal.style.display = 'none';
                video.pause();
                video.src = "";

                // Resume BGM if not a death cutscene
                if (music && !videoPath.includes('death.mp4')) {
                    playMusicWithRetry();
                }

                if (callback) {
                    callback();
                } else {
                    isPaused = false;
                    render();
                }
            };

            video.onerror = () => {
                console.error("Video failed to load:", videoPath);
                modal.style.display = 'none';

                if (music && !videoPath.includes('death.mp4')) {
                    playMusicWithRetry();
                }

                if (callback) {
                    callback();
                } else {
                    isPaused = false;
                    render();
                }
            };
        }

        window.playHowTo = function () {
            playCutscene('scene/rules.mp4');
        }

        window.startGameWithName = function () {
            const nameInput = document.getElementById('initial-player-name');
            const name = nameInput.value.trim() || "Anonymous Hero";
            localStorage.setItem('loki_player_name', name);
            document.getElementById('name-modal').style.display = 'none';
            isPaused = false;
            playMusicWithRetry();

            if (!localStorage.getItem('lokiRulesWatched')) {
                playCutscene('scene/rules.mp4', async () => {
                    localStorage.setItem('lokiRulesWatched', 'true');
                    await triggerLevelTransition(realms[0]);
                    startLevel();
                });
            } else {
                (async () => {
                    await triggerLevelTransition(realms[0]);
                    startLevel();
                })();
            }
        };

        window.onload = () => {
            const savedName = localStorage.getItem('loki_player_name');
            if (!savedName) {
                document.getElementById('name-modal').style.display = 'flex';
                isPaused = true;
            } else if (!localStorage.getItem('lokiRulesWatched')) {
                playCutscene('scene/rules.mp4', async () => {
                    localStorage.setItem('lokiRulesWatched', 'true');
                    await triggerLevelTransition(realms[0]);
                    startLevel();
                });
            } else {
                (async () => {
                    await triggerLevelTransition(realms[0]);
                    startLevel();
                })();
            }
        };
    </script>

</body>

</html>