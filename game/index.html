<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Loki: The Trickster's Trial</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@700&family=Cinzel:wght@400;700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="../style.css">
</head>

<body>
    <audio id="bg-music" loop>
        <source src="music/game.mp3" type="audio/mpeg">
    </audio>
    <audio id="gameover-music" loop>
        <source src="music/gameover.mp3" type="audio/mpeg">
    </audio>

    <div id="notification-container"></div>
    <div id="time-warp-overlay" class="time-warp-overlay">
        <h2 class="punishment-title">Your Punishment</h2>
        <div class="punishment-text">
            <p>The Gods brought you to a cave and took three rocks, which they bored holes in. The gods took a man's
                entrails and bound you to the rocks with those entrails. Someone placed a serpent above you so the venom
                of the serpent would fall on your face.</p>
            <p>Your wife stayed with you in the cave. There, she held a dish to get the venom out of your face. When the
                dish was full, she turned away to empty it. At such a moment, the venom dripped on your face. The pain
                was so real that you screamed and writhed. People believed that the earth was shaken every time you
                writhed.</p>
        </div>
        <button id="time-warp-continue" class="continue-btn">Continue</button>
    </div>
    <div id="transition-overlay">
        <img src="bunny_speaking.png" alt="The Norn Bunny"
            style="width: 150px; height: 150px; margin-bottom: 20px; filter: drop-shadow(0 0 20px var(--gold)); animation: floating 3s ease-in-out infinite;">
        <h2 id="transition-realm-name" style="position: relative;">Entering the Void</h2>

        <p id="transition-realm-desc"
            style="color: #ccc; font-family: 'Cormorant Garamond'; font-style: italic; font-size: 1.4em; max-width: 600px; line-height: 1.6; margin-top: 10px;">
        </p>
        <p style="color: #666; font-family: 'Cinzel'; letter-spacing: 5px; margin-top: 20px;">The Norn Bunny
            Foretells...</p>
        <button id="transition-continue" class="continue-btn">Continue</button>
    </div>

    <div id="death-screen">
        <h1 id="death-title">YOU PERISHED</h1>
        <p id="death-msg"></p>

        <div id="score-submit-container">
            <h3>Record your Legend</h3>
            <p>Runes: <span id="final-score">0</span></p>
            <input type="text" id="player-name" placeholder="Enter Hero Name" maxlength="15">
            <input type="email" id="player-email" placeholder="Email (@york.org)"
                style="margin-bottom: 15px; background: #000; border: 1px solid var(--gold); color: #fff; padding: 10px; font-family: 'Cinzel'; width: 80%; text-align: center;">
            <button id="submit-score-btn" onclick="submitScore()">Submit to Hall of Heroes</button>
        </div>

        <button onclick="location.reload()" style="margin-top: 20px;">REBORN</button>
    </div>

    <div id="name-modal" class="modal" style="display: none; z-index: 10002;">
        <div class="modal-content" style="text-align: center; height: auto; width: 450px;">
            <h2 style="color: var(--gold); font-family: 'Cinzel'; margin-top: 10px;">Whom do you represent?</h2>
            <p style="color: #ccc; font-style: italic; margin-bottom: 25px;">Enter your name to begin your journey
                through the Nine Realms.</p>
            <input type="text" id="initial-player-name" placeholder="Enter Legend Name" maxlength="15"
                style="background: #000; border: 1px solid var(--gold); color: var(--gold); padding: 12px; font-family: 'Cinzel', serif; text-align: center; font-size: 1.25em; width: 80%; margin-bottom: 25px; outline: none; box-shadow: 0 0 10px rgba(212, 175, 55, 0.2);">
            <div style="margin-bottom: 10px;">
                <button id="start-game-btn" onclick="startGameWithName()"
                    style="font-size: 1.2em; padding: 15px 50px;">Ascend</button>
            </div>
        </div>
    </div>


    <h1>LOKI</h1>
    <p class="instructions">"Glorious purpose awaits." Use WASD to traverse the Nine Realms. Collect Runes and find your
        Daggers to strike down enemies (1) or use Mischief (2) to confuse them. Collect <b>Space Stone fragments</b> to
        forge <b>Portals (P)</b> and skip through the void.</p>





    <div id="gatekeeper-modal" class="modal">
        <div class="modal-content">
            <h2 style="color: var(--gold); font-family: 'Cinzel';">The Gatekeeper's Trial</h2>
            <p id="gate-question-text" style="font-size: 1.2em; margin-bottom: 20px;"></p>

            <div id="gate-options-container"
                style="display: flex; flex-direction: column; gap: 10px; width: 80%; margin: 0 auto;"></div>

            <div style="margin-top: 20px; border-top: 1px solid #333; padding-top: 15px;">
                <button id="hint-btn" onclick="buyHint()"
                    style="background: #443300; border: 1px solid var(--gold); color: var(--gold); cursor: pointer; padding: 5px 10px;">
                    Buy Hint (150 Runes)
                </button>
                <p id="gate-hint-text" style="color: #aaa; font-style: italic; margin-top: 10px; display: none;"></p>
            </div>

            <p id="gate-feedback" style="margin-top: 15px; font-weight: bold;"></p>
        </div>
    </div>



    <div id="fight-modal" class="modal">
        <div class="modal-content fight-content">
            <iframe id="fight-frame" class="fight-frame" src=""></iframe>
        </div>
    </div>

    <div id="shop-modal" class="modal">
        <div class="modal-content"
            style="width: 900px; height: 600px; border: none; background: transparent; padding: 0;">
            <iframe id="shop-frame"
                style="width: 100%; height: 100%; border: 2px solid var(--gold); border-radius: 8px;" src=""></iframe>
        </div>
    </div>

    <div id="cutscene-modal" class="modal" style="background: black; z-index: 2000; display: none;">
        <video id="cutscene-video" style="width: 100%; height: 100%; object-fit: contain;" playsinline></video>
    </div>
    <div id="mischief-modal" class="modal">
        <div class="modal-content" style="text-align: center;">
            <h2 style="color: var(--gold); font-family: 'Cinzel';">Cast an Illusion</h2>
            <p id="mischief-target-info" style="font-size: 1.1em; margin-bottom: 20px;"></p>
            <div id="mischief-options-container"
                style="display: flex; flex-direction: column; gap: 10px; width: 85%; margin: 0 auto; margin-bottom: 25px;">
            </div>
            <div class="modal-buttons">
                <button onclick="closeMischief()" style="background: #330000; border-color: #600;">Withdraw</button>
            </div>
            <div id="mischief-result" class="mischief-result"
                style="margin-top: 20px; font-weight: bold; height: 1.5em;"></div>
        </div>
    </div>
    <div id="top-hud">
        <div class="hud-item" title="Current Realm">
            <span class="hud-label">Realm</span>
            <div style="display: flex; flex-direction: column; align-items: center;">
                <span id="level-text" class="hud-value">1</span>
                <span id="quirk-text"
                    style="font-size: 0.8em; color: var(--glitch-green); text-transform: uppercase; letter-spacing: 1px; font-weight: bold; margin-top: 5px; text-shadow: 0 0 10px var(--glitch-green);"></span>
            </div>
        </div>
        <div class="hud-item" title="Vitality">
            <span class="hud-label">Health</span>
            <div class="hud-stat-group">
                <span class="hud-icon">‚ù§Ô∏è</span>
                <span id="health-text" class="hud-value">100</span>
            </div>
        </div>
        <div class="hud-item" title="Runes Collected">
            <span class="hud-label">Runes</span>
            <div class="hud-stat-group">
                <span class="hud-icon">‚ú®</span>
                <span id="score-text" class="hud-value">0</span>
            </div>
        </div>
        <div class="hud-item" title="Space Stone Fragments">
            <span class="hud-label">Fragments</span>
            <div class="hud-stat-group">
                <span class="hud-icon" style="color: #00d4ff;">üíé</span>
                <span id="stone-text" class="hud-value" style="color: #00d4ff;">0</span>
            </div>
        </div>
        <div class="hud-item" title="Available Portals (Press P)">
            <span class="hud-label">Portals</span>
            <div class="hud-stat-group">
                <span class="hud-icon" style="color: #00ff41;">üåÄ</span>
                <span id="portal-text" class="hud-value" style="color: #00ff41;">0</span>
            </div>
        </div>
        <div class="hud-item" title="Mischief Charges (Press 2)">
            <span class="hud-label">Mischief</span>
            <div class="hud-stat-group">
                <span class="hud-icon">üé≠</span>
                <span id="mischief-status" class="hud-value">1</span>
            </div>
        </div>
        <div class="hud-item" title="Dagger Durability (Press 1)">
            <span class="hud-label">Daggers</span>
            <div class="hud-stat-group">
                <span class="hud-icon">üó°Ô∏è</span>
                <span id="weapon-text" class="hud-value">0</span>
            </div>
        </div>
        <div class="hud-item" title="Camp Out (Press 3) - Invulnerability & Fast-Forward" onclick="campOut()"
            style="cursor: pointer;">
            <span class="hud-label">Camp Out</span>
            <div class="hud-stat-group">
                <span class="hud-icon">‚õ∫</span>
                <span id="campout-text" class="hud-value">3</span>
            </div>
        </div>

        <!-- The Norn's Bazaar Shop Button -->
        <div
            style="position: absolute; right: 25px; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; align-items: center; gap: 4px;">
            <img src="bunny.png" alt="The Norn Bunny" onclick="openShop()"
                style="height: 48px; width: 48px; border-radius: 50%; border: 2px solid var(--gold); background: rgba(5, 18, 8, 0.95); padding: 4px; box-shadow: 0 0 15px rgba(212, 175, 55, 0.4); cursor: pointer; transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);"
                onmouseover="this.style.transform='scale(1.2) rotate(5deg)'; this.style.boxShadow='0 0 25px var(--gold)';"
                onmouseout="this.style.transform='scale(1) rotate(0deg)';" title="The Norn's Bazaar">
            <span
                style="font-size: 0.55em; color: var(--gold); text-transform: uppercase; letter-spacing: 1px; font-weight: bold; font-family: 'Cinzel';">Shop</span>
        </div>
    </div>
    <div class="ticker-container">
        <div class="ticker-wrap">
            <div id="main-ticker" class="ticker-move">
                <!-- Will be populated by JS -->
            </div>
        </div>
    </div>


    <div id="side-hud">
        <button class="side-item" onclick="openLeaderboard()" title="Hall of Heroes">
            <span class="side-icon">üèÜ</span>
            <span class="side-label">Heroes</span>
        </button>
        <button class="side-item" onclick="playHowTo()" title="Instructions">
            <span class="side-icon">‚ùì</span>
            <span class="side-label">Guide</span>
        </button>
        <button class="side-item" onclick="toggleGridView()" title="Toggle View Mode">
            <span class="side-icon">üëÅÔ∏è</span>
            <span id="view-text-side" class="side-label">Standard</span>
        </button>
        <button class="side-item" onclick="openCredits()" title="Credits">
            <span class="side-icon">üìú</span>
            <span class="side-label">Credits</span>
        </button>
        <button class="side-item" id="global-mute-btn" title="Toggle Global Mute">
            <span class="side-icon" id="mute-icon">üîä</span>
            <span class="side-label" id="mute-label">Mute</span>
        </button>
    </div>

    <!-- Credits Modal -->
    <div id="credits-modal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeCredits()">&times;</span>
            <iframe src="../credits/index.html" style="width: 100%; height: 100%; border: none;"></iframe>
        </div>
    </div>

    <!-- Leaderboard Modal -->
    <div id="leaderboard-modal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeLeaderboard()">&times;</span>
            <h2 style="text-align: center;">Hall of Heroes</h2>
            <div id="leaderboard-loading"
                style="text-align: center; color: var(--gold); display: flex; flex-direction: column; align-items: center; gap: 10px;">
                Communing with the Norns...
                <div id="leaderboard-splash" class="splash-text"
                    style="position: static; animation: splash-pulse 0.5s ease-in-out infinite; font-size: 0.8em; margin-top: 10px;">
                </div>
            </div>
            <table class="leaderboard-table" id="leaderboard-table" style="display: none;">
                <thead>
                    <tr>
                        <th>Hero</th>
                        <th>Runes</th>
                        <th>Realm</th>
                    </tr>
                </thead>
                <tbody id="leaderboard-body"></tbody>
            </table>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <!-- Image assets -->
    <div class="preload">
        <img id="hero-idle-weapon" src="hero/1.png" alt="hero idle weapon">
        <img id="hero-idle-no-weapon" src="hero/2.png" alt="hero idle no weapon">
        <img id="hero-run-1" src="hero/3.png" alt="hero run 1">
        <img id="hero-run-2" src="hero/4.png" alt="hero run 2">
        <img id="hero-run-3" src="hero/5.png" alt="hero run 3">
        <img id="hero-run-4" src="hero/6.png" alt="hero run 4">
        <img id="enemy-img" src="enemy.png" alt="enemy">
        <img id="enemy2-img" src="enemy2.png" alt="enemy elite">
        <img id="enemy3-img" src="enemy3.png" alt="enemy boss">
        <img id="coin-img" src="coin.png" alt="coin">
        <img id="weapon-img" src="swords.png" alt="weapon">
        <img id="potion-img" src="potion1.png" alt="health potion">
        <img id="bunny-img" src="bunny.png" alt="norn bunny">
        <img id="bunnyspeaking-img" src="bunny_speaking.png" alt="norn bunny speaking">
    </div>

    <script type="module">

        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-app.js";
        import { getFirestore, collection, addDoc, query, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyAPnWpytVCOF5UfryHEDCVe0fEs-Vx1xSE",
            authDomain: "loki-2dcab.firebaseapp.com",
            projectId: "loki-2dcab",
            storageBucket: "loki-2dcab.firebasestorage.app",
            messagingSenderId: "710391143408",
            appId: "1:710391143408:web:48667f1adfddbff5a15b35"
        };

        let db;
        let isFirebaseInitialized = false;

        window.debugGame = function () {
            console.log("--- LOKI GAME DEBUG ---");
            console.log("Level:", level);
            console.log("Player State:", player);
            console.log("Enemies Count:", enemies.length);
            console.log("Collectibles Count:", collectibles.length);
            console.log("Is Paused:", isPaused);
            console.log("Is Game Over:", isGameOver);
            console.log("Canvas Size:", canvas.width, "x", canvas.height);
            console.log("Assets Loaded Status:");
            for (let key in assets) {
                if (Array.isArray(assets[key])) {
                    assets[key].forEach((img, i) => console.log(`  ${key}[${i}]: ${img.complete ? 'COMPLETE' : 'LOADING'} (${img.src})`));
                } else {
                    console.log(`  ${key}: ${assets[key] ? (assets[key].complete ? 'COMPLETE' : 'LOADING') : 'NULL'} (${assets[key]?.src})`);
                }
            }
            return "Debug log finished.";
        };

        window.onerror = function (msg, url, line, col, error) {
            console.error("GLOBAL GAME ERROR:", msg, "at", url, ":", line, ":", col, error);
            return false;
        };

        try {
            // Check if coordinates have been replaced (they look like they have!)
            if (firebaseConfig.apiKey.startsWith("AIza")) {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                isFirebaseInitialized = true;
                console.log("Firebase initialized successfully");
            }
        } catch (e) {
            console.error("Firebase initialization failed:", e);
        }



        window.openLeaderboard = async function () {
            document.getElementById('leaderboard-modal').style.display = 'flex';
            const loadingEl = document.getElementById('leaderboard-loading');
            loadingEl.style.display = 'flex';
            document.getElementById('leaderboard-table').style.display = 'none';
            isPaused = true;

            // Set random splash with rotation
            fetch('../json/splash.json')
                .then(r => r.json())
                .then(splashes => {
                    const splashEl = document.getElementById('leaderboard-splash');
                    if (!splashEl) return;
                    const update = () => { splashEl.textContent = splashes[Math.floor(Math.random() * splashes.length)]; };
                    update();
                    const interval = setInterval(() => {
                        if (loadingEl.style.display === 'none') {
                            clearInterval(interval);
                        } else {
                            update();
                        }
                    }, 3000);
                });



            if (!isFirebaseInitialized) {
                // Show mock data if Firebase is not setup
                setTimeout(() => {
                    const mockData = [
                        { name: "Loki", score: 15400, realm: 9 },
                        { name: "Sylvie", score: 12200, realm: 7 },
                        { name: "Mobius", score: 8500, realm: 5 },
                        { name: "Thor", score: 5000, realm: 3 },
                        { name: "Odin", score: 3000, realm: 2 }
                    ];
                    const body = document.getElementById('leaderboard-body');
                    body.innerHTML = mockData.map(d => `<tr><td>${d.name}</td><td>${d.score}</td><td>${d.realm}</td></tr>`).join('');
                    document.getElementById('leaderboard-loading').style.display = 'none';
                    document.getElementById('leaderboard-table').style.display = 'table';
                }, 800);
                return;
            }

            try {
                const q = query(collection(db, "leaderboard"), orderBy("score", "desc"), limit(10));
                const querySnapshot = await getDocs(q);
                const body = document.getElementById('leaderboard-body');
                body.innerHTML = "";

                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    const row = `<tr>
                        <td>${data.name}</td>
                        <td>${data.score}</td>
                        <td>${data.realm}</td>
                    </tr>`;
                    body.innerHTML += row;
                });

                document.getElementById('leaderboard-loading').style.display = 'none';
                document.getElementById('leaderboard-table').style.display = 'table';
            } catch (e) {
                console.error("Error fetching leaderboard:", e);
                document.getElementById('leaderboard-loading').textContent = "Failed to load the Hall of Heroes.";
            }
        };

        window.closeLeaderboard = function () {
            document.getElementById('leaderboard-modal').style.display = 'none';
            isPaused = false;
            render();
        };

        window.submitScore = async function () {
            if (!isFirebaseInitialized) {
                showNotification("Firebase not configured. Score not saved locally.");
                document.getElementById('score-submit-container').style.display = 'none';
                openLeaderboard();
                return;
            }

            const name = document.getElementById('player-name').value.trim() || "Anonymous Hero";
            const email = document.getElementById('player-email').value.trim().toLowerCase();
            const score = player.totalScore;
            const realm = level;

            // Email Validation for york.org
            const localPart = email.split('@')[0];
            const domain = email.split('@')[1];

            if (domain !== 'york.org') {
                alert("Must be a @york.org email!");
                return;
            }

            const isStudent = localPart.endsWith('2030');
            const hasNumbers = /\d/.test(localPart);

            // Logic: If it has numbers, it MUST end in 2030. If it doesn't end in 2030, it MUST NOT have numbers.
            if (hasNumbers && !isStudent) {
                alert("Only 2030 student emails allowed. (Checked by database)");
                return;
            }

            const btn = document.getElementById('submit-score-btn');
            btn.disabled = true;
            btn.textContent = "Recording...";

            try {
                // Fetch user's IP address for DDoS prevention
                let userIp = "unknown";
                try {
                    const ipResponse = await fetch('https://api.ipify.org?format=json');
                    const ipData = await ipResponse.json();
                    userIp = ipData.ip;
                } catch (ipErr) {
                    console.error("Failed to fetch IP:", ipErr);
                }

                await addDoc(collection(db, "leaderboard"), {
                    name: name,
                    email: email,
                    score: score,
                    realm: realm,
                    ip: userIp,
                    timestamp: new Date()
                });

                // Save to localStorage for future runs
                localStorage.setItem('loki_player_name', name);
                localStorage.setItem('loki_player_email', email);

                showNotification("Your legend has been recorded!");
                document.getElementById('score-submit-container').style.display = 'none';
                openLeaderboard();
            } catch (e) {
                console.error("Error submitting score:", e);
                showNotification("The Norns rejected your score.");
                btn.disabled = false;
                btn.textContent = "Try Again";
            }
        };

        var currentGateAnswer = "";
        var currentGateHint = "";
        const music = document.getElementById('bg-music');
        const goMusic = document.getElementById('gameover-music');
        const muteBtn = document.getElementById('global-mute-btn');
        const muteIcon = document.getElementById('mute-icon');
        const muteLabel = document.getElementById('mute-label');

        let isMuted = localStorage.getItem('loki_muted') === 'true';

        function updateGlobalMute() {
            isMuted = localStorage.getItem('loki_muted') === 'true';
            if (music) music.muted = isMuted;
            if (goMusic) goMusic.muted = isMuted;

            // Also mute cutscene video if it exists
            const cutsceneVideo = document.getElementById('cutscene-video');
            if (cutsceneVideo) cutsceneVideo.muted = isMuted;

            muteIcon.textContent = isMuted ? 'üîá' : 'üîä';
            muteLabel.textContent = isMuted ? 'Unmute' : 'Mute';
        }

        muteBtn.addEventListener('click', () => {
            isMuted = !isMuted;
            localStorage.setItem('loki_muted', isMuted);
            updateGlobalMute();
        });

        // Sync across tabs
        window.addEventListener('storage', (e) => {
            if (e.key === 'loki_muted') {
                updateGlobalMute();
            }
        });

        // Initialize mute state
        updateGlobalMute();

        function playMusicWithRetry() {
            if (!music) return;
            music.play().catch(e => {
                console.log("Audio play postponed until interaction.");
            });
        }

        playMusicWithRetry();

        function showNotification(text) {
            const container = document.getElementById('notification-container');
            const note = document.createElement('div');
            note.className = 'notification';
            note.textContent = text;
            container.appendChild(note);

            setTimeout(() => {
                note.style.animation = 'fadeOut 1s forwards';
                setTimeout(() => note.remove(), 1000);
            }, 3000);
        }

        let canvasShake = { x: 0, y: 0, duration: 0 };

        function triggerShake(duration = 20) {
            canvasShake.duration = duration;
        }

        function animateValue(id, start, end, duration) {
            if (start === end) return;
            const obj = document.getElementById(id);
            const range = end - start;
            let startTime = null;

            function step(timestamp) {
                if (!startTime) startTime = timestamp;
                const progress = Math.min((timestamp - startTime) / duration, 1);
                obj.textContent = Math.floor(progress * range + start);
                if (progress < 1) {
                    window.requestAnimationFrame(step);
                } else {
                    obj.textContent = end;
                }
            }
            window.requestAnimationFrame(step);
        }

        function drawVignette(innerRadius = 2, outerRadius = 8, opacity = 0.85) {
            const vignette = ctx.createRadialGradient(
                player.x * TILE_SIZE + TILE_SIZE / 2, player.y * TILE_SIZE + TILE_SIZE / 2, TILE_SIZE * innerRadius,
                player.x * TILE_SIZE + TILE_SIZE / 2, player.y * TILE_SIZE + TILE_SIZE / 2, TILE_SIZE * outerRadius
            );
            vignette.addColorStop(0, 'rgba(0,0,0,0)');
            vignette.addColorStop(1, `rgba(0,0,0,${opacity})`);
            ctx.fillStyle = vignette;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        async function triggerLevelTransition(realmName) {
            // Fetch realm descriptions
            let realmDesc = "";
            try {
                const response = await fetch('questions/levels.json');
                const descriptions = await response.json();
                realmDesc = descriptions[realmName] || "";
            } catch (err) {
                console.error("Failed to load realm descriptions:", err);
            }

            return new Promise((resolve) => {
                const overlay = document.getElementById('transition-overlay');
                const realmText = document.getElementById('transition-realm-name');
                const descText = document.getElementById('transition-realm-desc');

                realmText.textContent = realmName || `Realm ${level}`;
                descText.textContent = realmDesc;

                // Random splash text from central JSON with rotation
                fetch('../json/splash.json')
                    .then(r => r.json())
                    .then(splashes => {
                        const splashEl = document.getElementById('game-splash-text');
                        if (!splashEl) return;
                        const update = () => { splashEl.textContent = splashes[Math.floor(Math.random() * splashes.length)]; };
                        update();
                        const interval = setInterval(update, 3000);
                        // Clear interval when overlay is hidden (roughly after resolve + fade)
                        setTimeout(() => clearInterval(interval), 5000);
                    });



                overlay.style.display = 'flex';
                const continueBtn = document.getElementById('transition-continue');
                overlay.classList.remove('show-content');
                continueBtn.classList.remove('visible');
                setTimeout(() => overlay.classList.add('active'), 50);

                const resolveTransition = () => {
                    overlay.classList.remove('active');
                    setTimeout(() => {
                        overlay.style.display = 'none';
                        resolve();
                    }, 800);
                    continueBtn.removeEventListener('click', resolveTransition);
                };

                // Apply the same 4.5s logic for "continue" button appearance
                setTimeout(() => {
                    continueBtn.classList.add('visible');
                    continueBtn.addEventListener('click', resolveTransition);
                }, 4500);
            });
        }

        const realms = ["Midgard", "Alfheim", "Asgard", "Jotunheim", "Vanaheim", "Nidavellir", "Muspelheim", "Niflheim", "Helheim"];
        const realmStyles = {
            "Midgard": { wall: '#0a210f', floor: '#061208', border: '#0e2e15', quirk: 'Lucky (Bonus Runes)' },
            "Alfheim": { wall: '#f0f4f8', floor: '#061208', border: '#a5b1c2', quirk: 'Radiant (High Visibility)' },
            "Asgard": { wall: '#d4af37', floor: '#061208', border: '#8c6d1f', quirk: 'Armory (Extra Daggers)' },
            "Jotunheim": { wall: '#00d4ff', floor: '#061208', border: '#0099cc', quirk: 'Frozen (Ancient Giants)' },
            "Vanaheim": { wall: '#004d26', floor: '#061208', border: '#003319', quirk: 'Mystical (Extra Potions)' },
            "Nidavellir": { wall: '#3d3d3d', floor: '#061208', border: '#262626', quirk: 'Hardened (Durable Daggers)' },
            "Muspelheim": { wall: '#ff4141', floor: '#061208', border: '#800000', quirk: 'Inferno (Swarms)' },
            "Niflheim": { wall: '#7f8c8d', floor: '#061208', border: '#95a5a6', quirk: 'Misty (Low Visibility)' },
            "Helheim": { wall: '#1a1a1a', floor: '#061208', border: '#333333', quirk: 'Cursed (Blindness)' }
        };

        window.showBunnyProphecy = function () {
            const realmName = realms[(level - 1) % realms.length];
            const currentStyle = realmStyles[realmName];
            showNotification(`The Norn Bunny whispers: You are in ${realmName} (Level ${level}). This realm is ${currentStyle.quirk}.`);
        };

        window.openShop = function () {
            const modal = document.getElementById('shop-modal');
            const frame = document.getElementById('shop-frame');
            frame.src = `shop/index.html?runes=${player.totalScore}`;
            modal.style.display = 'flex';
            isPaused = true;
        };

        window.closeShop = function () {
            document.getElementById('shop-modal').style.display = 'none';
            document.getElementById('shop-frame').src = '';
            isPaused = false;
            // Force focus back to game for controls
            window.focus();
            render();
        };

        // Close modals on click outside
        window.addEventListener('click', (event) => {
            const shopModal = document.getElementById('shop-modal');
            if (event.target === shopModal) {
                closeShop();
            }
            const mischiefModal = document.getElementById('mischief-modal');
            if (event.target === mischiefModal) {
                closeMischief();
            }
            const creditsModal = document.getElementById('credits-modal');
            if (event.target === creditsModal) {
                closeCredits();
            }
            const leaderboardModal = document.getElementById('leaderboard-modal');
            if (event.target === leaderboardModal) {
                closeLeaderboard();
            }
            const gatekeeperModal = document.getElementById('gatekeeper-modal');
            if (event.target === gatekeeperModal) {
                // Should probably not close gatekeeper by clicking outside as it's a trial
            }
        });

        async function nextLevel() {
            const realmName = realms[(level) % realms.length];

            isPaused = true;
            await triggerLevelTransition(realmName);
            level++;
            startLevel();
            isPaused = false;
        }

        // Initialize and rotate Main Game Ticker (Footer Bar)
        fetch('../json/splash.json')
            .then(r => r.json())
            .then(splashes => {
                const ticker = document.getElementById('main-ticker');
                if (!ticker) return;
                const update = () => {
                    ticker.innerHTML = `<div class="ticker-item">${splashes[Math.floor(Math.random() * splashes.length)]}</div>`;
                };
                update();
                setInterval(update, 3000);
            });



        function showDeathScreen(text) {
            text += "\nFun fact: Loki died while fighting Heimdall during Ragnarok."; isGameOver = true;
            isPaused = true;
            const screen = document.getElementById('death-screen');
            const msgEl = document.getElementById('death-msg');
            msgEl.textContent = text;
            screen.style.display = 'flex';
            screen.style.animation = 'fadeIn 2s forwards';

            // Show score submission
            document.getElementById('final-score').textContent = player.totalScore;
            document.getElementById('score-submit-container').style.display = 'flex';

            // Pre-fill name and email from localStorage
            const savedName = localStorage.getItem('loki_player_name') || "";
            const savedEmail = localStorage.getItem('loki_player_email') || "";
            document.getElementById('player-name').value = savedName;
            document.getElementById('player-email').value = savedEmail;

            // Stop background music
            music.pause();
            const goMusic = document.getElementById('gameover-music');
            if (goMusic && goMusic.paused) {
                goMusic.currentTime = 0;
                goMusic.play().catch(e => console.log("Game over music failed to play:", e));
            }
        }
        // --- GAME SETUP & CONFIG ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');


        const TILE_SIZE = 48; // Increased size for more detail
        const wallChar = '#';
        const floorChar = ' ';
        const exitChar = '>';

        let WALL_COLOR = '#0a210f';
        let FLOOR_COLOR = '#051208';
        let BORDER_COLOR = '#0e2e15';
        const RUNE_GLOW = '#d4af37';

        // --- ASSET MANAGEMENT ---
        const assets = {
            heroIdleWeapon: document.getElementById('hero-idle-weapon'),
            heroIdleNoWeapon: document.getElementById('hero-idle-no-weapon'),
            heroRun: [
                document.getElementById('hero-run-1'),
                document.getElementById('hero-run-2'),
                document.getElementById('hero-run-3'),
                document.getElementById('hero-run-4')
            ],
            enemy: document.getElementById('enemy-img'),
            enemy2: document.getElementById('enemy2-img'),
            enemy3: document.getElementById('enemy3-img'),
            coin: document.getElementById('coin-img'),
            weapon: document.getElementById('weapon-img'),
            potion: document.getElementById('potion-img'),
            spaceStone: null, // Drawing logic fallback
            portal: null
        };

        // --- GAME STATE ---
        let level = 1;
        let map = [];
        let player = {};
        let enemies = [];
        let collectibles = [];
        let portals = []; // Placed portals
        let mazeWidth, mazeHeight;
        let isGameOver = false;
        let isGridView = false; // Grid mode state

        // Animation state
        let heroAnimationFrame = 0;
        let isMoving = false;
        let moveAnimTimer = null;

        // --- MAZE GENERATION (Prim's Algorithm) ---
        function generateMaze(width, height) {
            width = width % 2 === 0 ? width + 1 : width;
            height = height % 2 === 0 ? height + 1 : height;
            mazeWidth = width;
            mazeHeight = height;

            let maze;
            let attempts = 0;
            const maxAttempts = 10;

            function isMazeUnoffensive(m) {
                const f = floorChar;
                for (let y = 2; y < height - 2; y++) {
                    for (let x = 2; x < width - 2; x++) {
                        if (m[y][x] === f) {
                            // Check for 5x5 offensive-symbol-like configurations (pinwheel arms)
                            // Clockwise
                            let cw = 0;
                            if (m[y - 1][x] === f && m[y - 2][x] === f && m[y - 2][x + 1] === f) cw++;
                            if (m[y + 1][x] === f && m[y + 2][x] === f && m[y + 2][x - 1] === f) cw++;
                            if (m[y][x + 1] === f && m[y][x + 2] === f && m[y + 1][x + 2] === f) cw++;
                            if (m[y][x - 1] === f && m[y][x - 2] === f && m[y - 1][x - 2] === f) cw++;
                            if (cw >= 3) return false;

                            // Counter-clockwise
                            let ccw = 0;
                            if (m[y - 1][x] === f && m[y - 2][x] === f && m[y - 2][x - 1] === f) ccw++;
                            if (m[y + 1][x] === f && m[y + 2][x] === f && m[y + 2][x + 1] === f) ccw++;
                            if (m[y][x + 1] === f && m[y][x + 2] === f && m[y - 1][x + 2] === f) ccw++;
                            if (m[y][x - 1] === f && m[y][x - 2] === f && m[y + 1][x - 2] === f) ccw++;
                            if (ccw >= 3) return false;
                        }
                    }
                }
                return true;
            }

            do {
                maze = Array(height).fill(null).map(() => Array(width).fill(wallChar));
                let startX = 1, startY = 1;
                maze[startY][startX] = floorChar;
                let walls = [];
                walls.push({ x: startX + 1, y: startY, fromX: startX, fromY: startY });
                walls.push({ x: startX - 1, y: startY, fromX: startX, fromY: startY });
                walls.push({ x: startX, y: startY + 1, fromX: startX, fromY: startY });
                walls.push({ x: startX, y: startY - 1, fromX: startX, fromY: startY });

                while (walls.length > 0) {
                    let wallIndex = Math.floor(Math.random() * walls.length);
                    let wall = walls[wallIndex];
                    let oppositeX = wall.x + (wall.x - wall.fromX);
                    let oppositeY = wall.y + (wall.y - wall.fromY);
                    if (oppositeY > 0 && oppositeY < height - 1 && oppositeX > 0 && oppositeX < width - 1 && maze[oppositeY][oppositeX] === wallChar) {
                        maze[wall.y][wall.x] = floorChar;
                        maze[oppositeY][oppositeX] = floorChar;
                        if (oppositeY > 1) walls.push({ x: oppositeX, y: oppositeY - 1, fromX: oppositeX, fromY: oppositeY });
                        if (oppositeY < height - 2) walls.push({ x: oppositeX, y: oppositeY + 1, fromX: oppositeX, fromY: oppositeY });
                        if (oppositeX > 1) walls.push({ x: oppositeX - 1, y: oppositeY, fromX: oppositeX, fromY: oppositeY });
                        if (oppositeX < width - 2) walls.push({ x: oppositeX + 1, y: oppositeY, fromX: oppositeX, fromY: oppositeY });
                    }
                    walls.splice(wallIndex, 1);
                }
                attempts++;
            } while (!isMazeUnoffensive(maze) && attempts < maxAttempts);

            maze[height - 2][width - 2] = exitChar;
            return maze.map(row => row.join(''));
        }

        // --- ENTITY PLACEMENT ---
        function populateMaze() {
            enemies = [];
            collectibles = [];
            let emptyTiles = [];
            for (let y = 0; y < mazeHeight; y++) {
                for (let x = 0; x < mazeWidth; x++) {
                    if (map[y][x] === floorChar && !(x === 1 && y === 1)) {
                        emptyTiles.push({ x, y });
                    }
                }
            }
            emptyTiles.sort(() => Math.random() - 0.5);

            // More enemies!
            const realmName = realms[(level - 1) % realms.length];
            const baseEnemyCount = (realmName === "Muspelheim" ? 4 : 2) + (level * 2);
            for (let i = 0; i < baseEnemyCount && emptyTiles.length > 0; i++) {
                const pos = emptyTiles.pop();

                // Determine Enemy Type and Level first
                let enemyLevel = 1;
                let type = 'normal';
                let img = 'enemy.png';

                const roll = Math.random();
                const realmName = realms[(level - 1) % realms.length];

                if (level >= 3 && roll > 0.85) {
                    enemyLevel = 3;
                    type = 'boss';
                    img = 'enemy3.png';
                } else if (level >= 2 && roll > 0.6) {
                    enemyLevel = 2;
                    type = 'elite';
                    img = 'enemy2.png';
                } else if (realmName === "Muspelheim") {
                    // Muspelheim quirk: More elites/aggressive spawning handled in count below
                }

                // Stats based on fixed level
                let hp = 50 + (enemyLevel * 25);
                let dmg = 5 + (enemyLevel * 5);

                if (type === 'boss') {
                    hp *= 2; // Extra beefy
                    dmg *= 1.5;
                } else if (type === 'elite') {
                    hp *= 1.3;
                    dmg *= 1.2;
                }

                enemies.push({
                    x: pos.x,
                    y: pos.y,
                    health: Math.floor(hp),
                    maxHealth: Math.floor(hp),
                    damage: Math.floor(dmg),
                    level: enemyLevel,
                    confused: false,
                    type: type,
                    img: img,
                    id: Math.random().toString(36).substr(2, 9)
                });
            }

            const coinCount = 5 + (level * 2);
            for (let i = 0; i < coinCount && emptyTiles.length > 0; i++) {
                const pos = emptyTiles.pop();
                collectibles.push({ x: pos.x, y: pos.y, type: 'coin' });
            }

            const weaponCount = (realmName === "Asgard" ? 2 : 1);
            for (let i = 0; i < weaponCount && emptyTiles.length > 0; i++) {
                const pos = emptyTiles.pop();
                collectibles.push({ x: pos.x, y: pos.y, type: 'weapon' });
            }

            // Health Potion Spawn (Increase chance in Vanaheim)
            const potionChance = (realmName === "Vanaheim" ? 0.7 : 0.3);
            if (Math.random() < potionChance && emptyTiles.length > 0) {
                const pos = emptyTiles.pop();
                collectibles.push({ x: pos.x, y: pos.y, type: 'potion' });
            }

            // Space Stone Fragments (3 fragments per level, but harder on Level 1)
            const stonesToSpawn = (level === 1) ? 1 : 3;
            for (let i = 0; i < stonesToSpawn && emptyTiles.length > 0; i++) {
                const pos = emptyTiles.pop();
                collectibles.push({ x: pos.x, y: pos.y, type: 'spaceStone' });
            }
        }

        // --- RENDER & UI ---
        function render() {
            try {
                if (!map || map.length === 0) return;
                const realmName = realms[(level - 1) % realms.length];
                const currentStyle = realmStyles[realmName];

                // Set Realm Colors
                WALL_COLOR = currentStyle.wall;
                FLOOR_COLOR = currentStyle.floor;
                BORDER_COLOR = currentStyle.border;

                canvas.width = mazeWidth * TILE_SIZE;
                canvas.height = mazeHeight * TILE_SIZE;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.save(); // Save state for whole render pass

                // Reset context state to defaults
                ctx.textAlign = 'start';
                ctx.textBaseline = 'alphabetic';
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1.0;

                // Apply Screen Shake
                if (canvasShake.duration > 0) {
                    const intensity = 5;
                    canvasShake.x = (Math.random() - 0.5) * intensity;
                    canvasShake.y = (Math.random() - 0.5) * intensity;
                    ctx.translate(canvasShake.x, canvasShake.y);
                    canvasShake.duration--;
                }

                // Draw Map
                for (let y = 0; y < map.length; y++) {
                    for (let x = 0; x < map[y].length; x++) {
                        const tileX = x * TILE_SIZE;
                        const tileY = y * TILE_SIZE;
                        if (map[y][x] === wallChar) {
                            // Wall Gradient
                            const grad = ctx.createLinearGradient(tileX, tileY, tileX + TILE_SIZE, tileY + TILE_SIZE);
                            grad.addColorStop(0, WALL_COLOR);
                            grad.addColorStop(1, '#051208');
                            ctx.fillStyle = grad;
                            ctx.fillRect(tileX, tileY, TILE_SIZE, TILE_SIZE);
                            ctx.strokeRect(tileX + 4, tileY + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                            ctx.strokeStyle = BORDER_COLOR;
                            ctx.strokeRect(tileX + 4, tileY + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                        } else {
                            ctx.fillStyle = FLOOR_COLOR;
                            ctx.fillRect(tileX, tileY, TILE_SIZE, TILE_SIZE);
                            if (map[y][x] === exitChar) {
                                ctx.save();
                                ctx.fillStyle = '#C0C0C0';
                                ctx.font = `bold ${TILE_SIZE * 0.8}px 'Cinzel'`;
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.shadowBlur = 10;
                                ctx.shadowColor = '#00ff41';
                                // Animated Exit
                                const pulseOffset = Math.sin(Date.now() / 300) * 5;
                                ctx.fillText('Œ©', tileX + TILE_SIZE / 2, tileY + TILE_SIZE / 2 + pulseOffset);
                                ctx.restore();
                            }
                        }
                    }
                }

                // Draw Assets
                collectibles.forEach(c => {
                    if (assets[c.type]) {
                        ctx.drawImage(assets[c.type], c.x * TILE_SIZE, c.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    } else if (c.type === 'spaceStone') {
                        // Drawing logic for Space Stone
                        ctx.save();
                        ctx.fillStyle = "#00d4ff";
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = "#00d4ff";
                        const centerX = c.x * TILE_SIZE + TILE_SIZE / 2;
                        const centerY = c.y * TILE_SIZE + TILE_SIZE / 2;
                        // Animated Rotation
                        const angle = Date.now() / 500;
                        ctx.translate(centerX, centerY);
                        ctx.rotate(angle);
                        ctx.beginPath();
                        ctx.moveTo(0, -TILE_SIZE / 4);
                        ctx.lineTo(TILE_SIZE / 4, 0);
                        ctx.lineTo(0, TILE_SIZE / 4);
                        ctx.lineTo(-TILE_SIZE / 4, 0);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    }
                });

                // Draw Portals
                portals.forEach(p => {
                    ctx.save();
                    ctx.strokeStyle = "#00ff41";
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 20 + Math.sin(Date.now() / 200) * 10;
                    ctx.shadowColor = "#00ff41";
                    const centerX = p.x * TILE_SIZE + TILE_SIZE / 2;
                    const centerY = p.y * TILE_SIZE + TILE_SIZE / 2;
                    const scale = 1 + Math.sin(Date.now() / 400) * 0.1;
                    ctx.beginPath();
                    ctx.ellipse(centerX, centerY, (TILE_SIZE / 3) * scale, (TILE_SIZE / 2) * scale, Math.sin(Date.now() / 1000) * 0.2, 0, Math.PI * 2);
                    ctx.stroke();

                    // Inner glow
                    ctx.fillStyle = "rgba(0, 255, 65, 0.2)";
                    ctx.fill();
                    ctx.restore();
                });

                enemies.forEach(e => {
                    let sprite = assets.enemy;
                    if (e.type === 'elite') sprite = assets.enemy2;
                    if (e.type === 'boss') sprite = assets.enemy3;

                    if (sprite && sprite.complete && sprite.naturalWidth > 0) {
                        ctx.drawImage(sprite, e.x * TILE_SIZE, e.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    } else {
                        // Fallback if sprite not loaded or broken
                        ctx.fillStyle = e.type === 'boss' ? "#aa00ff" : (e.type === 'elite' ? "#ff00ff" : "#ff0000");
                        ctx.fillRect(e.x * TILE_SIZE, e.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        ctx.strokeStyle = "white";
                        ctx.strokeRect(e.x * TILE_SIZE, e.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }

                    // HP Bar
                    ctx.fillStyle = "rgba(0,0,0,0.5)";
                    ctx.fillRect(e.x * TILE_SIZE, e.y * TILE_SIZE - 10, TILE_SIZE, 5);
                    ctx.fillStyle = e.isAlly ? "#00d4ff" : (e.confused ? "#00ff41" : "#ff0000");
                    if (e.type === 'boss') ctx.fillStyle = "#aa00ff";
                    ctx.fillRect(e.x * TILE_SIZE, e.y * TILE_SIZE - 10, (e.health / e.maxHealth) * TILE_SIZE, 5);

                    ctx.fillStyle = "white";
                    ctx.font = "10px Cinzel";
                    ctx.fillText(`Lvl ${e.level}`, e.x * TILE_SIZE, e.y * TILE_SIZE - 15);

                    if (e.confused) {
                        ctx.fillStyle = "#00ff41";
                        ctx.fillText("?", e.x * TILE_SIZE + TILE_SIZE / 2, e.y * TILE_SIZE + TILE_SIZE / 2);
                    }
                    if (e.isAlly) {
                        ctx.fillStyle = "#00d4ff";
                        ctx.font = "bold 12px Cinzel";
                        ctx.fillText("ALLY", e.x * TILE_SIZE, e.y * TILE_SIZE - 20);
                    }
                });

                let heroSprite;
                if (isMoving) {
                    heroSprite = assets.heroRun[heroAnimationFrame];
                } else {
                    heroSprite = player.hasWeapon ? assets.heroIdleWeapon : assets.heroIdleNoWeapon;
                }

                if (!heroSprite) heroSprite = assets.heroIdleNoWeapon;

                if (player.isInvulnerable) {
                    ctx.save();
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = "gold";
                    ctx.globalAlpha = 0.7 + Math.sin(Date.now() / 100) * 0.2;
                }

                if (heroSprite && heroSprite.complete && heroSprite.naturalWidth > 0) {
                    ctx.drawImage(heroSprite, player.x * TILE_SIZE, player.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                } else {
                    // Draw a placeholder if image is failing
                    ctx.fillStyle = "gold";
                    ctx.beginPath();
                    ctx.arc(player.x * TILE_SIZE + TILE_SIZE / 2, player.y * TILE_SIZE + TILE_SIZE / 2, TILE_SIZE / 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = "white";
                    ctx.stroke();
                }

                if (player.isInvulnerable) {
                    ctx.restore();
                }

                // Realm Effects
                if (realmName === "Helheim") {
                    drawVignette(2, 6, 0.98); // Blindness effect
                } else if (realmName === "Niflheim") {
                    drawVignette(4, 10, 0.7); // Mist effect
                }

                document.getElementById('level-text').textContent = `${realmName} (${level})`;
                const quirkEl = document.getElementById('quirk-text');
                if (quirkEl) quirkEl.textContent = currentStyle.quirk.split(' (')[0];
                document.getElementById('health-text').textContent = player.health;

                const oldScore = parseInt(document.getElementById('score-text').textContent);
                if (oldScore !== (player.totalScore || 0)) {
                    animateValue('score-text', oldScore, player.totalScore || 0, 500);
                }

                let weaponVal = '0';
                if (player.hasWeapon) {
                    weaponVal = player.weaponDurability;
                    document.getElementById('weapon-text').classList.add('ready-pulse');
                    document.getElementById('weapon-text').style.color = "#00ff41";
                } else {
                    document.getElementById('weapon-text').classList.remove('ready-pulse');
                    document.getElementById('weapon-text').style.color = "#ff4141";
                }
                document.getElementById('weapon-text').textContent = weaponVal;

                const mischiefEl = document.getElementById('mischief-status');
                if (mischiefEl) {
                    mischiefEl.textContent = player.mischiefCharges;
                    if (player.mischiefCharges <= 0) {
                        mischiefEl.style.color = "#ff4141";
                        mischiefEl.classList.remove('ready-pulse');
                    } else {
                        mischiefEl.style.color = "#00ff41";
                        mischiefEl.classList.add('ready-pulse');
                    }
                }

                // Update New HUD items
                document.getElementById('stone-text').textContent = player.spaceStones || 0;
                document.getElementById('portal-text').textContent = player.portals || 0;
                document.getElementById('campout-text').textContent = player.campOutCharges || 0;
                if (player.campOutCharges > 0) {
                    document.getElementById('campout-text').style.color = "#00ff41";
                } else {
                    document.getElementById('campout-text').style.color = "#ff4141";
                }

                // Update Side HUD
                const viewTextSide = document.getElementById('view-text-side');
                if (viewTextSide) {
                    viewTextSide.textContent = isGridView ? "Grid" : "Standard";
                }
            } catch (err) {
                console.error("Render failure on level", level, ":", err);
            }
        }

        function triggerTimeWarp() {
            const overlay = document.getElementById('time-warp-overlay');
            const continueBtn = document.getElementById('time-warp-continue');
            if (!overlay || !continueBtn) return;

            overlay.classList.add('active');
            document.body.classList.add('vibrate-container');
            continueBtn.classList.remove('visible');

            // Randomly shake the earth for 2 seconds
            const shake = setInterval(() => {
                triggerShake(20);
            }, 100);

            setTimeout(() => {
                clearInterval(shake);
                document.body.classList.remove('vibrate-container');
            }, 2000);

            const resolveWarp = () => {
                overlay.classList.remove('active');
                continueBtn.removeEventListener('click', resolveWarp);
            };

            // Only allow continue after 4.5 seconds
            setTimeout(() => {
                continueBtn.classList.add('visible');
                continueBtn.addEventListener('click', resolveWarp);
            }, 4500);
        }


        // --- ENEMY AI ---
        function processEnemyTurns() {
            enemies.forEach(enemy => {
                if (enemy.isAlly) {
                    // Allies follow player
                    const dx = player.x - enemy.x;
                    const dy = player.y - enemy.y;
                    if (Math.abs(dx) > 1 || Math.abs(dy) > 1) {
                        let stepX = enemy.x + (dx !== 0 ? Math.sign(dx) : 0);
                        let stepY = enemy.y + (dy !== 0 ? Math.sign(dy) : 0);
                        // Only move if not blocked
                        const isWall = map[stepY] && map[stepY][stepX] === wallChar;
                        const isOtherEnemy = enemies.some(e => e !== enemy && e.x === stepX && e.y === stepY);
                        if (!isWall && !isOtherEnemy) {
                            enemy.x = stepX;
                            enemy.y = stepY;
                        }
                    }
                    return;
                }
                if (enemy.confused) {
                    // Confused enemies might skip turn or move randomly even more
                    if (Math.random() > 0.5) return;
                }

                const dx = Math.abs(player.x - enemy.x);
                const dy = Math.abs(player.y - enemy.y);

                if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) {
                    if (enemy.level === 1) {
                        // Level 1 enemies only attack in 3D view
                        return;
                    }
                    if (!enemy.confused) {
                        if (!player.isInvulnerable) {
                            player.health -= enemy.damage;
                            triggerShake(15);
                        }
                    } else {
                        // Confused enemies might skip turn or move randomly even more
                        if (Math.random() > 0.5) {
                            if (!player.isInvulnerable) {
                                player.health -= Math.floor(enemy.damage / 2);
                                triggerShake(8);
                            }
                        }
                    }
                    return;
                }

                const move = Math.floor(Math.random() * 5);
                let newX = enemy.x;
                let newY = enemy.y;

                if (move === 1) newY--; else if (move === 2) newY++;
                else if (move === 3) newX--; else if (move === 4) newX++;

                const isWall = map[newY] && map[newY][newX] === wallChar;
                const isPlayer = newX === player.x && newY === player.y;
                const isOtherEnemy = enemies.some(e => e !== enemy && e.x === newX && e.y === newY);

                if (map[newY] && !isWall && !isPlayer && !isOtherEnemy) {
                    enemy.x = newX;
                    enemy.y = newY;
                }
            });
        }

        // --- MISCHIEF SYSTEM ---
        let currentTarget = null;

        async function openMischief() {
            if (player.mischiefCharges <= 0) {
                showNotification("Your trickery is exhausted. Visit the Norn's Bazaar to acquire more.");
                return;
            }

            // Find closest enemy
            let closest = null;
            let minDist = Infinity;
            enemies.forEach(e => {
                const dist = Math.sqrt(Math.pow(player.x - e.x, 2) + Math.pow(player.y - e.y, 2));
                if (dist < minDist && dist < 3 && !e.isAlly) {
                    minDist = dist;
                    closest = e;
                }
            });

            if (!closest) {
                showNotification("No enemies nearby to trick!");
                return;
            }

            currentTarget = closest;

            const modal = document.getElementById('mischief-modal');
            const optionsContainer = document.getElementById('mischief-options-container');
            const resultEl = document.getElementById('mischief-result');

            if (modal) {
                modal.style.display = 'flex';
                document.getElementById('mischief-target-info').textContent = `Target: Lvl ${currentTarget.level} Foe`;
                resultEl.textContent = '';
                optionsContainer.innerHTML = "<p style='color: var(--gold);'>Seeking trickster's inspiration...</p>";
                isPaused = true;

                try {
                    const response = await fetch('questions/mischief.json');
                    const options = await response.json();

                    // Shuffle and pick 4
                    const shuffled = options.sort(() => 0.5 - Math.random());
                    const selected = shuffled.slice(0, 4);

                    optionsContainer.innerHTML = "";
                    selected.forEach(opt => {
                        const btn = document.createElement('button');
                        btn.textContent = opt;
                        btn.className = "gate-option-btn";
                        btn.style = "padding: 12px; background: rgba(0,0,0,0.6); color: white; border: 1px solid var(--gold); cursor: pointer; font-family: 'Cinzel'; font-size: 0.9em; text-align: center; width: 100%; transition: all 0.2s;";
                        btn.onmouseover = () => { btn.style.background = "rgba(212, 175, 55, 0.2)"; };
                        btn.onmouseout = () => { btn.style.background = "rgba(0,0,0,0.6)"; };
                        btn.onclick = () => window.executeMischief(opt);
                        optionsContainer.appendChild(btn);
                    });
                } catch (err) {
                    console.error("Failed to load mischief options:", err);
                    optionsContainer.innerHTML = "<p style='color: #ff4141;'>The Void is silent. Trickery failed.</p>";
                }
            } else {
                console.error("Could not find mischief-modal element!");
            }
        }

        window.closeMischief = function () {
            document.getElementById('mischief-modal').style.display = 'none';
            isPaused = false;
            render();
        }

        window.executeMischief = async function (choice) {
            const resultEl = document.getElementById('mischief-result');
            const optionsContainer = document.getElementById('mischief-options-container');

            // Disable all buttons to prevent double-click
            Array.from(optionsContainer.getElementsByTagName('button')).forEach(b => {
                b.disabled = true;
                b.style.opacity = "0.5";
                b.style.cursor = "default";
            });

            resultEl.textContent = "The Norn Bunny decides your fate...";
            resultEl.style.color = "var(--gold)";

            // 75% success rate for mischief
            const success = Math.random() > 0.25;

            setTimeout(() => {
                if (success) {
                    if (currentTarget.level === 1) {
                        resultEl.textContent = "Loki cackles - the level 1 foe is now your ally!";
                        resultEl.style.color = "#00ff41";
                        currentTarget.isAlly = true;
                        currentTarget.confused = false;
                        currentTarget.damage = Math.floor(currentTarget.damage * 1.5); // Allies hit harder
                        showNotification("Enemy Tamed! They will follow you and aid in 3D combat.");
                    } else {
                        resultEl.textContent = "Loki's trick is lethal! The level 2+ foe perishes!";
                        resultEl.style.color = "#00ff41";
                        const idx = enemies.indexOf(currentTarget);
                        if (idx !== -1) enemies.splice(idx, 1);
                        player.totalScore += 150;
                    }
                } else {
                    resultEl.textContent = "The trick backfires! The foe is enraged!";
                    resultEl.style.color = "#ff4141";
                    currentTarget.damage = Math.floor(currentTarget.damage * 1.5);

                    // Dock 90 health and trigger Time Warp
                    player.health -= 90;
                    if (player.health < 0) player.health = 0;
                    document.getElementById('health-text').textContent = player.health;
                    triggerTimeWarp();
                    showNotification("The venom of the trickery falls upon you! -90 HP");
                }

                player.mischiefCharges--;

                setTimeout(() => {
                    closeMischief();
                    processEnemyTurns();
                    render();
                }, 1500);
            }, 1000);
        }
        window.openCredits = function () {
            document.getElementById('credits-modal').style.display = 'flex';
            isPaused = true;
        }

        window.closeCredits = function () {
            document.getElementById('credits-modal').style.display = 'none';
            isPaused = false;
            render();
        }

        let isPaused = false;

        // --- COMBAT SYSTEM (3D) ---
        let combatEnemyIndex = -1;

        window.addEventListener('message', (event) => {
            if (event.data.type === 'fight-result') {
                endCombat(event.data.won, event.data.playerHP);
            }
            if (event.data.type === 'cheat-health') {
                player.health = event.data.health;
                render();
            }

            if (event.data.type === 'buy-swords') {
                player.totalScore -= event.data.price;
                player.weaponDurability += 10;
                player.hasWeapon = true;
                showNotification("Acquired 10 Daggers!");
                updateShopRunes();
                render();
            }

            if (event.data.type === 'buy-mischief') {
                player.totalScore -= event.data.price;
                player.mischiefCharges += 2;
                showNotification("Acquired 2 Mischief Charges!");
                updateShopRunes();
                render();
            }

            if (event.data.type === 'buy-potion') {
                player.totalScore -= event.data.price;
                player.health = 100;
                showNotification("Restored Health!");
                playCutscene('scene/health.mp4');
                updateShopRunes();
                render();
            }

            if (event.data.type === 'buy-campout') {
                player.totalScore -= event.data.price;
                player.campOutCharges += 1;
                showNotification("Acquired Camping Supplies!");
                updateShopRunes();
                render();
            }

            if (event.data.type === 'buy-prophecy') {
                showBunnyProphecy();
            }
        });

        function updateShopRunes() {
            const frame = document.getElementById('shop-frame');
            if (frame && frame.contentWindow) {
                frame.contentWindow.postMessage({ type: 'update-runes', runes: player.totalScore }, '*');
            }
        }

        function startCombat(enemyIndex) {
            if (player.weaponDurability <= 0) return;

            const enemy = enemies[enemyIndex];
            combatEnemyIndex = enemyIndex;

            document.getElementById('fight-modal').style.display = 'flex';
            const frame = document.getElementById('fight-frame');

            // Pass stats to 3D fight
            // current health, damage, and image params
            const ally = enemies.find(e => e.isAlly);
            const allyParam = ally ? `&allyImg=${ally.img}&allyDmg=${ally.damage}` : "";
            frame.src = `3D/index.html?hp=${enemy.health}&dmg=${enemy.damage}&img=${enemy.img}&playerHP=${player.health}${allyParam}`;

            // Ensure focus for interaction
            frame.onload = () => {
                frame.contentWindow.focus();
            };

            isPaused = true;
        }


        function endCombat(won, remainingHP) {
            document.getElementById('fight-modal').style.display = 'none';
            document.getElementById('fight-frame').src = ''; // Unload to stop loops
            isPaused = false;

            if (combatEnemyIndex !== -1 && won) {
                const enemy = enemies[combatEnemyIndex];
                // Victory logic
                enemies.splice(combatEnemyIndex, 1);

                // Reward based on enemy type
                let reward = 10;
                let scoreGain = 100;
                if (enemy.type === 'elite') { reward = 25; scoreGain = 250; }
                if (enemy.type === 'boss') { reward = 100; scoreGain = 1000; }

                player.coins += reward;
                player.totalScore += scoreGain;
                showNotification(`Foe Vanquished! +${scoreGain} Score`);

                player.weaponDurability--;
                if (player.weaponDurability <= 0) player.hasWeapon = false;

                processEnemyTurns();
            } else if (combatEnemyIndex !== -1 && !won) {
                player.health = 0;
                playCutscene('scene/death.mp4', () => {
                    showDeathScreen("You fell in battle. The Valkyries did not come.");
                });
            }

            if (remainingHP !== undefined) {
                player.health = remainingHP;
            }
            combatEnemyIndex = -1;
            render();
        }

        // --- GAME CONTROL ---
        function startLevel() {
            console.log("Starting Level:", level);
            isGameOver = false;
            const width = 13 + (level * 2);
            const height = 9 + (level * 2);
            console.log("Maze dimensions:", width, "x", height);

            player = {
                x: 1, y: 1,
                health: player.health || 100,
                coins: player.coins || 0,
                totalScore: player.totalScore || 0,
                hasWeapon: player.hasWeapon || false,
                weaponDurability: player.weaponDurability || 0,
                spaceStones: player.spaceStones || 0,
                portals: player.portals || 0,
                mischiefCharges: player.mischiefCharges === undefined ? 1 : player.mischiefCharges,
                campOutCharges: 3,
                isInvulnerable: false
            };

            portals = []; // Clear portals each level
            map = generateMaze(width, height);
            populateMaze();
            render();
            console.log("Level", level, "initialized. Player at:", player.x, player.y);
        }

        document.addEventListener('keydown', function (event) {
            if (event.key === 'Escape') {
                if (document.getElementById('shop-modal').style.display === 'flex') closeShop();
                if (document.getElementById('mischief-modal').style.display === 'flex') closeMischief();
                if (document.getElementById('credits-modal').style.display === 'flex') closeCredits();
                if (document.getElementById('leaderboard-modal').style.display === 'flex') closeLeaderboard();
            }

            if (isGameOver || isPaused) return;

            let newX = player.x;
            let newY = player.y;
            let playerAction = false;

            const key = event.key.toLowerCase();
            if (key === 'w') { newY--; playerAction = true; }
            else if (key === 's') { newY++; playerAction = true; }
            else if (key === 'a') { newX--; playerAction = true; }
            else if (key === 'd') { newX++; playerAction = true; }
            else if (key === 'p') { // Place Portal
                if (player.portals > 0) {
                    player.portals--;
                    portals.push({ x: player.x, y: player.y });
                    showNotification("Portal Opened! Enter to skip realms.");
                } else {
                    showNotification("Collect 3 Space Stone fragments to forge a portal!");
                }
                render();
                return;
            }
            else if (key === 'v') { // Toggle Grid Mode
                toggleGridView();
                return;
            }
            else if (key === '1') { // Combat
                if (player.hasWeapon && player.weaponDurability > 0) {
                    // Find closest valid enemy
                    let targetIdx = -1;
                    for (let i = 0; i < enemies.length; i++) {
                        const enemy = enemies[i];
                        const dx = Math.abs(player.x - enemy.x);
                        const dy = Math.abs(player.y - enemy.y);
                        if (((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) && !enemy.isAlly) {
                            targetIdx = i;
                            break;
                        }
                    }

                    if (targetIdx !== -1) {
                        startCombat(targetIdx);
                        return; // Wait for async fight
                    }
                }
            } else if (key === '2') { // Mischief
                openMischief();
            } else if (key === '3') { // Camp Out
                campOut();
            } else {
                return;
            }
            event.preventDefault();

            const isEnemy = enemies.some(e => e.x === newX && e.y === newY && !e.isAlly);
            if (map[newY] && map[newY][newX] !== wallChar && !isEnemy) {
                const dx = newX - player.x;
                const dy = newY - player.y;

                player.x = newX;
                player.y = newY;

                // Jotunheim Ice Quirk: Slide removed per Alex's request to fix 2 block move bug
                // If you want to re-implement, use a while loop for a full slide until wall. (AI)

                // Handle running animation
                if (playerAction && (key === 'w' || key === 's' || key === 'a' || key === 'd')) {
                    isMoving = true;
                    if (moveAnimTimer) clearInterval(moveAnimTimer);

                    let frameCount = 0;
                    moveAnimTimer = setInterval(() => {
                        heroAnimationFrame = (heroAnimationFrame + 1) % 4;
                        render();
                        frameCount++;
                        if (frameCount > 8) { // Animation duration
                            clearInterval(moveAnimTimer);
                            isMoving = false;
                            heroAnimationFrame = 0;
                            render();
                        }
                    }, 50); // Fast succession
                }
            }

            collectibles.forEach((c, index) => {
                if (player.x === c.x && player.y === c.y) {
                    if (c.type === 'coin') {
                        const realmName = realms[(level - 1) % realms.length];
                        const bonus = (realmName === "Midgard" ? 200 : 100);
                        player.totalScore += bonus;
                        if (realmName === "Midgard") showNotification("Midgard's Blessing! +100 Lucky Bonus");
                    }
                    if (c.type === 'weapon') {
                        player.hasWeapon = true;
                        const realmName = realms[(level - 1) % realms.length];
                        const durabilityBonus = (realmName === "Nidavellir" ? 10 : 0);
                        player.weaponDurability = 10 + level + durabilityBonus;
                        player.totalScore += 50;
                    }
                    if (c.type === 'potion') {
                        player.health = 100;
                        player.totalScore += 25;
                        playCutscene('scene/health.mp4');
                    }
                    if (c.type === 'spaceStone') {
                        player.spaceStones++;
                        player.totalScore += 50;
                        showNotification(`Space Stone Fragment Collected! (${player.spaceStones}/3)`);
                        if (player.spaceStones >= 3) {
                            player.spaceStones -= 3;
                            player.portals++;
                            showNotification("Tesseract Fragment Forged! Portal Ready (Press P)");
                        }
                    }
                    collectibles.splice(index, 1);
                }
            });

            // Check for Portal interaction
            portals.forEach((p, index) => {
                if (player.x === p.x && player.y === p.y) {
                    showNotification("Entering the Void... Skipping 5 Realms!");
                    portals.splice(index, 1);
                    setTimeout(async () => {
                        level += 4; // Add 4 here because nextLevel adds 1
                        await nextLevel();
                    }, 500);
                }
            });

            // Inside your document.addEventListener('keydown', ...) 
            if (map[player.y][player.x] === exitChar) {
                // Instead of level++ and startLevel(), trigger the question
                askGatekeeperQuestion();
                return;
            }
            if (playerAction) {
                processEnemyTurns();
            }


            async function askGatekeeperQuestion() {
                isPaused = true;
                const modal = document.getElementById('gatekeeper-modal');
                const questionEl = document.getElementById('gate-question-text');
                const optionsContainer = document.getElementById('gate-options-container');
                const feedbackEl = document.getElementById('gate-feedback');
                const hintText = document.getElementById('gate-hint-text');
                const hintBtn = document.getElementById('hint-btn');

                feedbackEl.textContent = "";
                hintText.style.display = 'none';
                hintBtn.style.display = 'inline-block';
                optionsContainer.innerHTML = "Loading choices...";
                modal.style.display = 'flex';

                try {
                    const response = await fetch('questions/list.json');
                    const questions = await response.json();

                    if (questions && questions.length > 0) {
                        const randomQ = questions[Math.floor(Math.random() * questions.length)];
                        questionEl.textContent = randomQ.question;
                        currentGateAnswer = randomQ.answer;
                        currentGateHint = randomQ.hint;

                        optionsContainer.innerHTML = "";
                        randomQ.options.forEach(option => {
                            const btn = document.createElement('button');
                            btn.textContent = option;
                            btn.className = "gate-option-btn"; // Add a class for CSS styling
                            btn.style = "padding: 10px; background: #111; color: white; border: 1px solid var(--gold); cursor: pointer; font-family: 'Cinzel';";
                            btn.onclick = () => checkGateAnswer(option);
                            optionsContainer.appendChild(btn);
                        });
                    }
                } catch (e) {
                    console.error("Error:", e);
                    questionEl.textContent = "Fallout: Who is the God of Mischief?";
                    currentGateAnswer = "Loki";
                    currentGateHint = "It's the name of this game.";
                    optionsContainer.innerHTML = `<button onclick="checkGateAnswer('Loki')">Loki</button>`;
                }
            }

            window.checkGateAnswer = function (selectedOption) {
                const feedbackEl = document.getElementById('gate-feedback');

                if (selectedOption === currentGateAnswer) {
                    feedbackEl.textContent = "Correct. You may pass.";
                    feedbackEl.style.color = "#00ff41";
                    player.totalScore += 500;
                    showNotification("Level Cleared! +500 Score");
                    setTimeout(async () => {
                        document.getElementById('gatekeeper-modal').style.display = 'none';
                        await nextLevel();
                    }, 1000);
                } else {
                    feedbackEl.textContent = "Incorrect. The Bifrost remains closed.";
                    feedbackEl.style.color = "#ff4141";

                    // Dock 50 health and trigger Time Warp
                    player.health -= 50;
                    if (player.health < 0) player.health = 0;
                    document.getElementById('health-text').textContent = player.health;
                    triggerTimeWarp();
                    showNotification("The Gatekeeper's wrath shakes the earth! -50 HP");

                    if (player.health <= 0) {
                        player.health = 0;
                        playCutscene('scene/death.mp4', () => {
                            showDeathScreen("The Gatekeeper's judgement was final. You are no more.");
                        });
                    }
                }
            };

            window.buyHint = function () {
                const hintText = document.getElementById('gate-hint-text');
                const hintBtn = document.getElementById('hint-btn');

                if (player.totalScore >= 150) {
                    player.totalScore -= 150;
                    document.getElementById('score-text').textContent = player.totalScore;
                    hintText.textContent = "Hint: " + currentGateHint;
                    hintText.style.display = 'block';
                    hintBtn.style.display = 'none';
                } else {
                    showNotification("You do not have enough Runes! (Need 150)");
                }
            };

            if (player.health <= 0) {
                player.health = 0;
                playCutscene('scene/death.mp4', () => {
                    showDeathScreen("Your life force fades. Ragnarok has come for you.");
                });
            }

            render();
        });

        window.campOut = function () {
            if (isGameOver || isPaused) return;
            if (player.campOutCharges <= 0) {
                showNotification("No Camp Out charges left in this realm!");
                return;
            }

            player.campOutCharges--;
            player.isInvulnerable = true;
            isPaused = true;
            showNotification("Camping Out... Invulnerable while time flows forward!");

            // Move enemies 10x
            let moves = 0;
            const moveInterval = setInterval(() => {
                processEnemyTurns();
                render();
                moves++;
                if (moves >= 10) {
                    clearInterval(moveInterval);
                    player.isInvulnerable = false;
                    isPaused = false;
                    showNotification("Camp Out finished.");
                    render();
                }
            }, 100); // 100ms between each "fast" move
        };

        function toggleGridView() {
            isGridView = !isGridView;
            const canvasEl = document.getElementById('gameCanvas');
            const viewText = document.getElementById('view-text-side');

            if (isGridView) {
                canvasEl.classList.add('grid-mode');
                if (viewText) viewText.textContent = "Grid";
                showNotification("Grid Mode / Mini-Map Enabled");
            } else {
                canvasEl.classList.remove('grid-mode');
                if (viewText) viewText.textContent = "Standard";
                showNotification("Standard View Enabled");
            }
            render();
        }

        // --- SECRET CHEAT CODES ---
        let cheatBuffer = "";
        const secretLevel = "banana";
        const secretPotion = "ballers"; // New code

        document.addEventListener('keydown', (e) => {
            cheatBuffer += e.key.toLowerCase();

            // Keep the buffer at a reasonable length
            if (cheatBuffer.length > 10) {
                cheatBuffer = cheatBuffer.slice(-10);
            }

            // Existing Level Skip
            if (cheatBuffer.endsWith(secretLevel)) {
                console.log("üçå Secret Activated: Moving to next level!");
                level++;
                startLevel();
                cheatBuffer = "";
            }

            // NEW: Potion Spawn
            if (cheatBuffer.endsWith(secretPotion)) {
                console.log("üíé Potion Summoned!");
                spawnPotionNextToPlayer();
                cheatBuffer = "";
            }
        });

        // --- CONSOLE CHEATS ---
        // Access these via the browser's Developer Console (F12)
        window.addRunes = (amount) => {
            if (typeof amount !== 'number') return "Please provide a number (e.g., addRunes(1000))";
            player.totalScore = (player.totalScore || 0) + amount;
            render();
            showNotification(`Runes Granted: +${amount}`);
            return `New Balance: ${player.totalScore} Runes`;
        };

        window.setRunes = (amount) => {
            if (typeof amount !== 'number') return "Please provide a number (e.g., setRunes(5000))";
            player.totalScore = amount;
            render();
            return `Projected Balance: ${player.totalScore} Runes`;
        };


        function spawnPotionNextToPlayer() {
            // Look at adjacent tiles (Up, Down, Left, Right)
            const directions = [
                { x: 0, y: -1 }, { x: 0, y: 1 },
                { x: -1, y: 0 }, { x: 1, y: 0 }
            ];

            for (let dir of directions) {
                let targetX = player.x + dir.x;
                let targetY = player.y + dir.y;

                // Check if the tile is a floor and doesn't already have a collectible
                const isFloor = map[targetY] && map[targetY][targetX] === floorChar;
                const isOccupied = collectibles.some(c => c.x === targetX && c.y === targetY);
                const hasEnemy = enemies.some(e => e.x === targetX && e.y === targetY);

                if (isFloor && !isOccupied && !hasEnemy) {
                    collectibles.push({ x: targetX, y: targetY, type: 'potion' });
                    render(); // Refresh the canvas to show the potion
                    return; // Exit after spawning one
                }
            }
            showNotification("No room to spawn a potion here!");
        }

        // --- CUTSCENE LOGIC ---
        function playCutscene(videoPath, callback) {
            const modal = document.getElementById('cutscene-modal');
            const video = document.getElementById('cutscene-video');

            if (music) music.pause();

            isPaused = true;
            modal.style.display = 'flex';
            video.src = videoPath;

            if (videoPath.includes('death.mp4')) {
                const goMusic = document.getElementById('gameover-music');
                if (goMusic) {
                    goMusic.currentTime = 0;
                    goMusic.play().catch(e => console.log("Game over music failed to play during cutscene:", e));
                }
            }

            video.play().catch(e => {
                console.log("Autoplay prevented, trying mute", e);
                video.muted = true;
                video.play();
            });

            video.onended = () => {
                modal.style.display = 'none';
                video.pause();
                video.src = "";

                // Resume BGM if not a death cutscene
                if (music && !videoPath.includes('death.mp4')) {
                    playMusicWithRetry();
                }

                if (callback) {
                    callback();
                } else {
                    isPaused = false;
                    render();
                }
            };

            video.onerror = () => {
                console.error("Video failed to load:", videoPath);
                modal.style.display = 'none';

                if (music && !videoPath.includes('death.mp4')) {
                    playMusicWithRetry();
                }

                if (callback) {
                    callback();
                } else {
                    isPaused = false;
                    render();
                }
            };
        }

        window.playHowTo = function () {
            playCutscene('scene/rules.mp4');
        }

        window.startGameWithName = function () {
            const nameInput = document.getElementById('initial-player-name');
            const name = nameInput.value.trim() || "Anonymous Hero";
            localStorage.setItem('loki_player_name', name);
            document.getElementById('name-modal').style.display = 'none';
            isPaused = false;
            playMusicWithRetry();

            if (!localStorage.getItem('lokiRulesWatched')) {
                playCutscene('scene/rules.mp4', async () => {
                    localStorage.setItem('lokiRulesWatched', 'true');
                    await triggerLevelTransition(realms[0]);
                    startLevel();
                });
            } else {
                (async () => {
                    await triggerLevelTransition(realms[0]);
                    startLevel();
                })();
            }
        };

        window.onload = () => {
            const savedName = localStorage.getItem('loki_player_name');
            if (!savedName) {
                document.getElementById('name-modal').style.display = 'flex';
                isPaused = true;
            } else if (!localStorage.getItem('lokiRulesWatched')) {
                playCutscene('scene/rules.mp4', async () => {
                    localStorage.setItem('lokiRulesWatched', 'true');
                    await triggerLevelTransition(realms[0]);
                    startLevel();
                });
            } else {
                (async () => {
                    await triggerLevelTransition(realms[0]);
                    startLevel();
                })();
            }
        };
    </script>

</body>

</html>