<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Loki: The Trickster's Trial</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@700&family=Cinzel:wght@400;700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="../style.css">
</head>

<body>

    <h1>LOKI</h1>
    <p class="instructions">"Glorious purpose awaits." Use WASD to traverse the Nine Realms. Collect Runes and find your
        Daggers to strike down enemies (1) or use Mischief (2) to confuse them.</p>

    <div id="mischief-modal" class="modal">
        <div class="modal-content">
            <h2>Cast an Illusion</h2>
            <p id="mischief-target-info"></p>
            <textarea id="mischief-input" placeholder="Type how you will confuse this foe..."></textarea>
            <div class="modal-buttons">
                <button id="mischief-submit" onclick="submitMischief()">Deceive</button>
                <button onclick="closeMischief()">Withdraw</button>
            </div>
            <div id="mischief-result" class="mischief-result"></div>
        </div>
    </div>

    <div id="fight-modal" class="modal">
        <div class="modal-content fight-content">
            <iframe id="fight-frame" class="fight-frame" src=""></iframe>
        </div>
    </div>

    <div id="cutscene-modal" class="modal" style="background: black; z-index: 2000; display: none;">
        <video id="cutscene-video" style="width: 100%; height: 100%; object-fit: contain;" playsinline></video>
    </div>

    <div id="hud">
        <div class="hud-item">
            <span class="hud-label">Realm Verse</span>
            <span id="level-text" class="hud-value">1</span>
        </div>
        <div class="hud-item">
            <span class="hud-label">Vitality</span>
            <span id="health-text" class="hud-value">100</span>
        </div>
        <div class="hud-item">
            <span class="hud-label">Asgardian Runes</span>
            <span id="coin-text" class="hud-value">0</span>
        </div>
        <div class="hud-item">
            <span class="hud-label">Relic</span>
            <span id="weapon-text" class="hud-value">Unarmed</span>
        </div>
        <div class="hud-item">
            <span class="hud-label">Mischief</span>
            <span id="mischief-status" class="hud-value">Ready</span>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <!-- Image assets -->
    <div class="preload">
        <img id="hero-idle-weapon" src="hero/1.png" alt="hero idle weapon">
        <img id="hero-idle-no-weapon" src="hero/2.png" alt="hero idle no weapon">
        <img id="hero-run-1" src="hero/3.png" alt="hero run 1">
        <img id="hero-run-2" src="hero/4.png" alt="hero run 2">
        <img id="hero-run-3" src="hero/5.png" alt="hero run 3">
        <img id="hero-run-4" src="hero/6.png" alt="hero run 4">
        <img id="enemy-img" src="enemy.png" alt="enemy">
        <img id="enemy2-img" src="enemy2.png" alt="enemy elite">
        <img id="enemy3-img" src="enemy3.png" alt="enemy boss">
        <img id="coin-img" src="coin.png" alt="coin">
        <img id="weapon-img" src="sword.png" alt="weapon">
        <img id="potion-img" src="potion1.png" alt="health potion">
    </div>

    <script>
        // --- GAME SETUP & CONFIG ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const TILE_SIZE = 48; // Increased size for more detail
        const wallChar = '#';
        const floorChar = ' ';
        const exitChar = '>';

        const WALL_COLOR = '#0a210f'; // Deep jungle green
        const FLOOR_COLOR = '#051208'; // Almost black green
        const RUNE_GLOW = '#d4af37';

        // --- ASSET MANAGEMENT ---
        const assets = {
            heroIdleWeapon: document.getElementById('hero-idle-weapon'),
            heroIdleNoWeapon: document.getElementById('hero-idle-no-weapon'),
            heroRun: [
                document.getElementById('hero-run-1'),
                document.getElementById('hero-run-2'),
                document.getElementById('hero-run-3'),
                document.getElementById('hero-run-4')
            ],
            enemy: document.getElementById('enemy-img'),
            enemy2: document.getElementById('enemy2-img'),
            enemy3: document.getElementById('enemy3-img'),
            coin: document.getElementById('coin-img'),
            weapon: document.getElementById('weapon-img'),
            potion: document.getElementById('potion-img')
        };

        // --- GAME STATE ---
        let level = 1;
        let map = [];
        let player = {};
        let enemies = [];
        let collectibles = [];
        let mazeWidth, mazeHeight;
        let isGameOver = false;

        // Animation state
        let heroAnimationFrame = 0;
        let isMoving = false;
        let moveAnimTimer = null;

        // --- MAZE GENERATION (Prim's Algorithm) ---
        function generateMaze(width, height) {
            width = width % 2 === 0 ? width + 1 : width;
            height = height % 2 === 0 ? height + 1 : height;
            mazeWidth = width;
            mazeHeight = height;

            let maze = Array(height).fill(null).map(() => Array(width).fill(wallChar));
            let startX = 1, startY = 1;
            maze[startY][startX] = floorChar;
            let walls = [];
            walls.push({ x: startX + 1, y: startY, fromX: startX, fromY: startY });
            walls.push({ x: startX - 1, y: startY, fromX: startX, fromY: startY });
            walls.push({ x: startX, y: startY + 1, fromX: startX, fromY: startY });
            walls.push({ x: startX, y: startY - 1, fromX: startX, fromY: startY });

            while (walls.length > 0) {
                let wallIndex = Math.floor(Math.random() * walls.length);
                let wall = walls[wallIndex];
                let oppositeX = wall.x + (wall.x - wall.fromX);
                let oppositeY = wall.y + (wall.y - wall.fromY);
                if (oppositeY > 0 && oppositeY < height - 1 && oppositeX > 0 && oppositeX < width - 1 && maze[oppositeY][oppositeX] === wallChar) {
                    maze[wall.y][wall.x] = floorChar;
                    maze[oppositeY][oppositeX] = floorChar;
                    if (oppositeY > 1) walls.push({ x: oppositeX, y: oppositeY - 1, fromX: oppositeX, fromY: oppositeY });
                    if (oppositeY < height - 2) walls.push({ x: oppositeX, y: oppositeY + 1, fromX: oppositeX, fromY: oppositeY });
                    if (oppositeX > 1) walls.push({ x: oppositeX - 1, y: oppositeY, fromX: oppositeX, fromY: oppositeY });
                    if (oppositeX < width - 2) walls.push({ x: oppositeX + 1, y: oppositeY, fromX: oppositeX, fromY: oppositeY });
                }
                walls.splice(wallIndex, 1);
            }
            maze[height - 2][width - 2] = exitChar;
            return maze.map(row => row.join(''));
        }

        // --- ENTITY PLACEMENT ---
        function populateMaze() {
            enemies = [];
            collectibles = [];
            let emptyTiles = [];
            for (let y = 0; y < mazeHeight; y++) {
                for (let x = 0; x < mazeWidth; x++) {
                    if (map[y][x] === floorChar && !(x === 1 && y === 1)) {
                        emptyTiles.push({ x, y });
                    }
                }
            }
            emptyTiles.sort(() => Math.random() - 0.5);

            // More enemies!
            const baseEnemyCount = 2 + (level * 2);
            for (let i = 0; i < baseEnemyCount && emptyTiles.length > 0; i++) {
                const pos = emptyTiles.pop();
                const enemyLevel = Math.floor(Math.random() * level) + level;

                // Enemy Type Logic
                let type = 'normal';
                let img = 'enemy.png';
                let hp = 50 + (enemyLevel * 10);
                let dmg = 5 + enemyLevel;

                const roll = Math.random();

                // Check Boss FIRST so they aren't masked by Elite check
                // Making them spawn more (Level 3+, >85% roll)
                if (level >= 3 && roll > 0.85) {
                    type = 'boss';
                    img = 'enemy3.png';
                    hp *= 3;
                    dmg *= 2;
                } else if (level >= 2 && roll > 0.6) {
                    type = 'elite';
                    img = 'enemy2.png';
                    hp *= 1.5;
                    dmg *= 1.5;
                }

                enemies.push({
                    x: pos.x,
                    y: pos.y,
                    health: Math.floor(hp),
                    maxHealth: Math.floor(hp),
                    damage: Math.floor(dmg),
                    level: enemyLevel,
                    confused: false,
                    type: type,
                    img: img,
                    id: Math.random().toString(36).substr(2, 9)
                });
            }

            const coinCount = 5 + (level * 2);
            for (let i = 0; i < coinCount && emptyTiles.length > 0; i++) {
                const pos = emptyTiles.pop();
                collectibles.push({ x: pos.x, y: pos.y, type: 'coin' });
            }

            if (emptyTiles.length > 0) {
                const pos = emptyTiles.pop();
                collectibles.push({ x: pos.x, y: pos.y, type: 'weapon' });
            }

            // Health Potion Spawn (30% chance)
            if (Math.random() < 0.3 && emptyTiles.length > 0) {
                const pos = emptyTiles.pop();
                collectibles.push({ x: pos.x, y: pos.y, type: 'potion' });
            }
        }

        // --- RENDER & UI ---
        function render() {
            canvas.width = mazeWidth * TILE_SIZE;
            canvas.height = mazeHeight * TILE_SIZE;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw Map
            for (let y = 0; y < map.length; y++) {
                for (let x = 0; x < map[y].length; x++) {
                    const tileX = x * TILE_SIZE;
                    const tileY = y * TILE_SIZE;
                    if (map[y][x] === wallChar) {
                        ctx.fillStyle = WALL_COLOR;
                        ctx.fillRect(tileX, tileY, TILE_SIZE, TILE_SIZE);
                        // Add some "stone" detail
                        ctx.strokeStyle = '#0e2e15';
                        ctx.strokeRect(tileX + 4, tileY + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                    } else {
                        ctx.fillStyle = FLOOR_COLOR;
                        ctx.fillRect(tileX, tileY, TILE_SIZE, TILE_SIZE);
                        if (map[y][x] === exitChar) {
                            ctx.fillStyle = '#C0C0C0';
                            ctx.font = `bold ${TILE_SIZE * 0.8}px 'Cinzel'`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.shadowBlur = 10;
                            ctx.shadowColor = '#00ff41';
                            ctx.fillText('Î©', tileX + TILE_SIZE / 2, tileY + TILE_SIZE / 2);
                            ctx.shadowBlur = 0;
                        }
                    }
                }
            }

            // Draw Assets
            collectibles.forEach(c => ctx.drawImage(assets[c.type], c.x * TILE_SIZE, c.y * TILE_SIZE, TILE_SIZE, TILE_SIZE));
            enemies.forEach(e => {
                let sprite = assets.enemy;
                if (e.type === 'elite') sprite = assets.enemy2;
                if (e.type === 'boss') sprite = assets.enemy3;

                ctx.drawImage(sprite, e.x * TILE_SIZE, e.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                // Health bar and level
                ctx.fillStyle = "rgba(0,0,0,0.5)";
                ctx.fillRect(e.x * TILE_SIZE, e.y * TILE_SIZE - 10, TILE_SIZE, 5);
                ctx.fillStyle = e.confused ? "#00ff41" : "#ff0000";
                if (e.type === 'boss') ctx.fillStyle = "#aa00ff"; // Purple bar for boss
                ctx.fillRect(e.x * TILE_SIZE, e.y * TILE_SIZE - 10, (e.health / e.maxHealth) * TILE_SIZE, 5);

                ctx.fillStyle = "white";
                ctx.font = "10px Cinzel";
                ctx.fillText(`Lvl ${e.level}`, e.x * TILE_SIZE, e.y * TILE_SIZE - 15);

                if (e.confused) {
                    ctx.fillStyle = "#00ff41";
                    ctx.fillText("?", e.x * TILE_SIZE + TILE_SIZE / 2, e.y * TILE_SIZE + TILE_SIZE / 2);
                }
            });
            // Draw Hero with Animation logic
            let heroSprite;
            if (isMoving) {
                heroSprite = assets.heroRun[heroAnimationFrame];
            } else {
                heroSprite = player.hasWeapon ? assets.heroIdleWeapon : assets.heroIdleNoWeapon;
            }
            if (!heroSprite) heroSprite = assets.heroIdleNoWeapon; // Fallback
            ctx.drawImage(heroSprite, player.x * TILE_SIZE, player.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);

            // Update HUD
            document.getElementById('level-text').textContent = level;
            document.getElementById('health-text').textContent = player.health;
            document.getElementById('coin-text').textContent = player.coins;
            let weaponText = 'Unarmed';
            if (player.hasWeapon) {
                weaponText = `Twin Daggers (${player.weaponDurability})`;
                document.getElementById('weapon-text').classList.add('ready-pulse');
                document.getElementById('weapon-text').style.color = "#00ff41";
            } else {
                document.getElementById('weapon-text').classList.remove('ready-pulse');
                document.getElementById('weapon-text').style.color = "#ff4141";
            }
            document.getElementById('weapon-text').textContent = weaponText;

            const mischiefEl = document.getElementById('mischief-status');
            mischiefEl.textContent = mischiefUsed ? "Exhausted" : "Ready";
            if (mischiefUsed) {
                mischiefEl.style.color = "#ff4141";
                mischiefEl.classList.remove('ready-pulse');
            } else {
                mischiefEl.style.color = "#00ff41";
                mischiefEl.classList.add('ready-pulse');
            }
        }

        // --- ENEMY AI ---
        function processEnemyTurns() {
            enemies.forEach(enemy => {
                if (enemy.confused) {
                    // Confused enemies might skip turn or move randomly even more
                    if (Math.random() > 0.5) return;
                }

                const dx = Math.abs(player.x - enemy.x);
                const dy = Math.abs(player.y - enemy.y);

                if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) {
                    if (!enemy.confused) {
                        player.health -= enemy.damage;
                    } else {
                        // Confused enemies deal less damage or miss
                        if (Math.random() > 0.5) {
                            player.health -= Math.floor(enemy.damage / 2);
                        }
                    }
                    return;
                }

                const move = Math.floor(Math.random() * 5);
                let newX = enemy.x;
                let newY = enemy.y;

                if (move === 1) newY--; else if (move === 2) newY++;
                else if (move === 3) newX--; else if (move === 4) newX++;

                const isWall = map[newY] && map[newY][newX] === wallChar;
                const isPlayer = newX === player.x && newY === player.y;
                const isOtherEnemy = enemies.some(e => e !== enemy && e.x === newX && e.y === newY);

                if (map[newY] && !isWall && !isPlayer && !isOtherEnemy) {
                    enemy.x = newX;
                    enemy.y = newY;
                }
            });
        }

        // --- MISCHIEF SYSTEM ---
        let currentTarget = null;
        let mischiefUsed = false;

        function openMischief() {
            if (mischiefUsed) {
                alert("Your trickery is exhausted for this realm. Wait for the next.");
                return;
            }
            // Find closest enemy
            let closest = null;
            let minDist = Infinity;
            enemies.forEach(e => {
                const dist = Math.sqrt(Math.pow(player.x - e.x, 2) + Math.pow(player.y - e.y, 2));
                if (dist < minDist && dist < 3) { // Must be within 3 tiles
                    minDist = dist;
                    closest = e;
                }
            });

            if (!closest) {
                alert("No enemies nearby to trick!");
                return;
            }

            currentTarget = closest;
            document.getElementById('mischief-modal').style.display = 'flex';
            document.getElementById('mischief-target-info').textContent = `Target: Lvl ${currentTarget.level} Foe`;
            document.getElementById('mischief-input').value = '';
            document.getElementById('mischief-result').textContent = '';
            isPaused = true;
        }

        function closeMischief() {
            document.getElementById('mischief-modal').style.display = 'none';
            isPaused = false;
            render();
        }

        function submitMischief() {
            const text = document.getElementById('mischief-input').value;
            if (!text.trim()) return;

            const resultEl = document.getElementById('mischief-result');
            resultEl.textContent = "Judging your deception...";

            // Artificial delay to feel like AI is thinking
            setTimeout(() => {
                const successChance = 0.5 + (level / (currentTarget.level * 2));
                const rolls = Math.random();
                const isSuccess = rolls < successChance;

                if (isSuccess) {
                    resultEl.textContent = "Success! The fool is confounded by your illusions.";
                    resultEl.style.color = "#00ff41";
                    currentTarget.confused = true;
                    // Lower enemy's level metaphorically
                    currentTarget.damage = Math.max(1, currentTarget.damage - 5);
                    mischiefUsed = true;
                } else {
                    resultEl.textContent = "Failure! Your trickery was too transparent.";
                    resultEl.style.color = "#ff4141";
                    // Enemy gets angry!
                    currentTarget.damage += 5;
                    mischiefUsed = true;
                }

                setTimeout(() => {
                    closeMischief();
                    processEnemyTurns();
                    render();
                }, 1500);
            }, 1000);
        }

        let isPaused = false;

        // --- COMBAT SYSTEM (3D) ---
        let combatEnemyIndex = -1;

        window.addEventListener('message', (event) => {
            if (event.data.type === 'fight-result') {
                endCombat(event.data.won, event.data.playerHP);
            }
            if (event.data.type === 'cheat-health') {
                player.health = event.data.health;
                render();
            }
        });

        function startCombat(enemyIndex) {
            if (player.weaponDurability <= 0) return;

            const enemy = enemies[enemyIndex];
            combatEnemyIndex = enemyIndex;

            document.getElementById('fight-modal').style.display = 'flex';
            const frame = document.getElementById('fight-frame');

            // Pass stats to 3D fight
            // current health, damage, and image params
            frame.src = `3D/index.html?hp=${enemy.health}&dmg=${enemy.damage}&img=${enemy.img}&playerHP=${player.health}`;

            // Ensure focus for interaction
            frame.onload = () => {
                frame.contentWindow.focus();
            };

            isPaused = true;
        }


        function endCombat(won, remainingHP) {
            document.getElementById('fight-modal').style.display = 'none';
            document.getElementById('fight-frame').src = ''; // Unload to stop loops
            isPaused = false;

            if (combatEnemyIndex !== -1 && won) {
                // Victory logic
                enemies.splice(combatEnemyIndex, 1);
                player.coins += 10;
                player.weaponDurability--;
                if (player.weaponDurability <= 0) player.hasWeapon = false;

                // Process a turn for safety (enemies might move after a fight)
                processEnemyTurns();
            } else if (combatEnemyIndex !== -1 && !won) {
                // Defeat logic
                player.health = 0;
                isGameOver = true;
                alert("You fell in battle. The Valkyries did not come.");
            }

            if (remainingHP !== undefined) {
                player.health = remainingHP;
            }
            combatEnemyIndex = -1;
            render();
        }

        // --- GAME CONTROL ---
        function startLevel() {
            isGameOver = false;
            mischiefUsed = false;
            const width = 13 + (level * 2);
            const height = 9 + (level * 2);

            player = {
                x: 1, y: 1,
                health: player.health || 100,
                coins: player.coins || 0,
                hasWeapon: player.hasWeapon || false,
                weaponDurability: player.weaponDurability || 0
            };

            map = generateMaze(width, height);
            populateMaze();
            render();
        }

        document.addEventListener('keydown', function (event) {
            if (isGameOver || isPaused) return;

            let newX = player.x;
            let newY = player.y;
            let playerAction = false;

            const key = event.key.toLowerCase();
            if (key === 'w') { newY--; playerAction = true; }
            else if (key === 's') { newY++; playerAction = true; }
            else if (key === 'a') { newX--; playerAction = true; }
            else if (key === 'd') { newX++; playerAction = true; }
            else if (key === '1') { // Combat
                if (player.hasWeapon && player.weaponDurability > 0) {
                    // Find closest valid enemy
                    let targetIdx = -1;
                    for (let i = 0; i < enemies.length; i++) {
                        const enemy = enemies[i];
                        const dx = Math.abs(player.x - enemy.x);
                        const dy = Math.abs(player.y - enemy.y);
                        if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) {
                            targetIdx = i;
                            break;
                        }
                    }

                    if (targetIdx !== -1) {
                        startCombat(targetIdx);
                        return; // Wait for async fight
                    }
                }
            } else if (key === '2') { // Mischief
                openMischief();
            } else {
                return;
            }
            event.preventDefault();

            const isEnemy = enemies.some(e => e.x === newX && e.y === newY);
            if (map[newY] && map[newY][newX] !== wallChar && !isEnemy) {
                player.x = newX;
                player.y = newY;

                // Handle running animation
                if (playerAction && (key === 'w' || key === 's' || key === 'a' || key === 'd')) {
                    isMoving = true;
                    if (moveAnimTimer) clearInterval(moveAnimTimer);

                    let frameCount = 0;
                    moveAnimTimer = setInterval(() => {
                        heroAnimationFrame = (heroAnimationFrame + 1) % 4;
                        render();
                        frameCount++;
                        if (frameCount > 8) { // Animation duration
                            clearInterval(moveAnimTimer);
                            isMoving = false;
                            heroAnimationFrame = 0;
                            render();
                        }
                    }, 50); // Fast succession
                }
            }

            collectibles.forEach((c, index) => {
                if (player.x === c.x && player.y === c.y) {
                    if (c.type === 'coin') player.coins++;
                    if (c.type === 'weapon') {
                        player.hasWeapon = true;
                        player.weaponDurability = 10 + level;
                    }
                    if (c.type === 'potion') {
                        player.health = 100;
                        playCutscene('scene/health.mp4');
                    }
                    collectibles.splice(index, 1);
                }
            });

            if (map[player.y][player.x] === exitChar) {
                level++;
                startLevel();
                return;
            }

            if (playerAction) {
                processEnemyTurns();
            }

            if (player.health <= 0) {
                player.health = 0;
                isGameOver = true;
                alert("Your life force fades. Ragnarok has come for you. Refresh to reborn.");
            }

            render();
        });

        // --- SECRET CHEAT CODES ---
        let cheatBuffer = "";
        const secretLevel = "banana";
        const secretPotion = "ballers"; // New code

        document.addEventListener('keydown', (e) => {
            cheatBuffer += e.key.toLowerCase();

            // Keep the buffer at a reasonable length
            if (cheatBuffer.length > 10) {
                cheatBuffer = cheatBuffer.slice(-10);
            }

            // Existing Level Skip
            if (cheatBuffer.endsWith(secretLevel)) {
                console.log("ðŸŒ Secret Activated: Moving to next level!");
                level++;
                startLevel();
                cheatBuffer = "";
            }

            // NEW: Potion Spawn
            if (cheatBuffer.endsWith(secretPotion)) {
                console.log("ðŸ’Ž Potion Summoned!");
                spawnPotionNextToPlayer();
                cheatBuffer = "";
            }
        });

        function spawnPotionNextToPlayer() {
            // Look at adjacent tiles (Up, Down, Left, Right)
            const directions = [
                { x: 0, y: -1 }, { x: 0, y: 1 },
                { x: -1, y: 0 }, { x: 1, y: 0 }
            ];

            for (let dir of directions) {
                let targetX = player.x + dir.x;
                let targetY = player.y + dir.y;

                // Check if the tile is a floor and doesn't already have a collectible
                const isFloor = map[targetY] && map[targetY][targetX] === floorChar;
                const isOccupied = collectibles.some(c => c.x === targetX && c.y === targetY);
                const hasEnemy = enemies.some(e => e.x === targetX && e.y === targetY);

                if (isFloor && !isOccupied && !hasEnemy) {
                    collectibles.push({ x: targetX, y: targetY, type: 'potion' });
                    render(); // Refresh the canvas to show the potion
                    return; // Exit after spawning one
                }
            }
            alert("No room to spawn a potion here!");
        }

        // --- CUTSCENE LOGIC ---
        function playCutscene(videoPath) {
            const modal = document.getElementById('cutscene-modal');
            const video = document.getElementById('cutscene-video');

            isPaused = true;
            modal.style.display = 'flex';
            video.src = videoPath;

            video.play().catch(e => {
                console.log("Autoplay prevented, trying mute", e);
                video.muted = true;
                video.play();
            });

            video.onended = () => {
                modal.style.display = 'none';
                video.pause();
                video.src = "";
                isPaused = false;
                render();
                // Ensure music resumes if we had any
            };
        }

        window.onload = () => {
            startLevel();
        };
    </script>

</body>

</html>