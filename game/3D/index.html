<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Loki Sword Fight</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Cinzel', serif;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            z-index: 10;
            pointer-events: none;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            background: transparent;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #sword-overlay {
            position: absolute;
            bottom: -50px;
            right: 10%;
            width: 300px;
            height: auto;
            transform-origin: bottom right;
            transition: transform 0.1s;
            pointer-events: none;
        }

        .swing {
            animation: swingAnimation 0.3s ease-in-out;
        }

        @keyframes swingAnimation {
            0% {
                transform: rotate(0deg) translateX(0);
            }

            50% {
                transform: rotate(-45deg) translateX(-50px);
            }

            100% {
                transform: rotate(0deg) translateX(0);
            }
        }

        .damage-flash {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: red;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }
    </style>
</head>

<body>
    <div id="ui">
        <h1>Duel for Survival</h1>
        <p>Left Click: Strike | Space/Right Click: Block</p>
        <div id="status-bar" style="margin-top:10px; font-size:1.2em; color:#d4af37;"></div>
        <p>Enemy HP: <span id="enemy-hp">100</span></p>
        <p>Your HP: <span id="player-hp">100</span></p>
    </div>
    <div id="crosshair"></div>
    <div class="damage-flash" id="flash"></div>
    <div id="block-shield"
        style="position:absolute; bottom:0; left:0; right:0; top:0; border: 20px solid rgba(0, 255, 255, 0.3); display:none; pointer-events:none; box-shadow: inset 0 0 50px cyan;">
    </div>
    <img id="sword-overlay" src="../sword-f.png" alt="Sword">

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

        // --- URL PARAMS ---
        const urlParams = new URLSearchParams(window.location.search);
        const startEnemyHP = parseInt(urlParams.get('hp')) || 100;
        const enemyDamage = parseInt(urlParams.get('dmg')) || 15;
        const enemyImgSrc = urlParams.get('img') || 'enemy.png';
        const isBoss = enemyImgSrc.includes('enemy3');

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a0524);
        scene.fog = new THREE.Fog(0x1a0524, 0, 20);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;
        camera.position.y = 1.6;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(0, 10, 5);
        scene.add(dirLight);

        // --- ENEMY ---
        const textureLoader = new THREE.TextureLoader();
        const enemyTexture = textureLoader.load('../' + enemyImgSrc);
        enemyTexture.magFilter = THREE.NearestFilter;

        const enemyMaterial = new THREE.SpriteMaterial({ map: enemyTexture, color: 0xffffff });
        const enemy = new THREE.Sprite(enemyMaterial);

        // Scale boss differently
        if (isBoss) {
            enemy.scale.set(6, 6, 1);
            enemy.position.set(0, 2.5, 0);
        } else {
            enemy.scale.set(3, 3, 1);
            enemy.position.set(0, 1.6, 0);
        }
        scene.add(enemy);

        // --- FLOOR ---
        const floorGeo = new THREE.PlaneGeometry(30, 30);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x0a210f, roughness: 0.8 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        // --- GAME STATE ---
        let enemyHP = startEnemyHP;
        let playerHP = 100;
        let isFighting = true;
        let isBlocking = false;
        let enemyState = 'IDLE'; // IDLE, CHARGING, ATTACKING, RECOVERING
        let lastAttackTime = 0;
        const keys = { w: false, a: false, s: false, d: false };

        const swordImg = document.getElementById('sword-overlay');
        const flash = document.getElementById('flash');
        const shieldEl = document.getElementById('block-shield');
        const statusEl = document.getElementById('status-bar');

        document.getElementById('enemy-hp').textContent = enemyHP;

        // --- PLAYER ACTIONS ---
        function attack() {
            if (!isFighting || isBlocking || Date.now() - lastAttackTime < 500) return;
            lastAttackTime = Date.now();

            // Animate Sword
            swordImg.classList.remove('swing');
            void swordImg.offsetWidth;
            swordImg.classList.add('swing');

            // Hit logic
            setTimeout(() => {
                let damage = 10;
                // Bonus damage if enemy is recovering check
                if (enemyState === 'RECOVERING') {
                    damage *= 2; // Critical hit!
                    showMessage("CRITICAL HIT!", "#ff0");
                }

                enemyHP -= damage;
                document.getElementById('enemy-hp').textContent = enemyHP;

                // Visual feedback
                enemy.material.color.set(0xff0000);
                setTimeout(() => enemy.material.color.set(0xffffff), 100);

                if (enemyHP <= 0) {
                    endFight(true);
                }
            }, 100);
        }

        function setBlock(blocking) {
            if (!isFighting) return;
            isBlocking = blocking;

            if (isBlocking) {
                // visual shield
                shieldEl.style.display = 'block';
                swordImg.style.transform = 'rotate(-20deg) translateX(-100px) translateY(50px)'; // Hide sword a bit
            } else {
                shieldEl.style.display = 'none';
                swordImg.style.transform = '';
            }
        }

        // --- ENEMY AI LOOP ---
        function updateEnemyAI() {
            if (!isFighting || enemyHP <= 0) return;

            const now = Date.now();

            // AI State Machine
            if (enemyState === 'IDLE') {
                // Randomly decide to attack
                if (Math.random() < 0.02) { // approx 1/sec check at 60fps
                    startCharge();
                }
            }
        }

        function startCharge() {
            enemyState = 'CHARGING';
            // Visual tell
            enemy.material.color.set(0xffaa00); // Orange tint
            showMessage("ENEMY PREPARING ATTACK!", "#ffa500");

            // Charge time depends on difficulty/boss
            const chargeTime = isBoss ? 500 : 800;

            setTimeout(() => {
                enemy.material.color.set(0xffffff);
                performEnemyAttack();
            }, chargeTime);
        }

        function performEnemyAttack() {
            if (!isFighting) return;
            enemyState = 'ATTACKING';

            // Lunge animation
            // Smooth lunge could be better, but simple pos change for now
            // Simple "hit" moment
            setTimeout(() => {
                if (isBlocking) {
                    // Blocked!
                    showMessage("BLOCKED!", "#0ff");
                    // Recoil
                } else {
                    // Hit!
                    playerHP -= enemyDamage;
                    document.getElementById('player-hp').textContent = playerHP;
                    flash.style.opacity = 0.5;
                    setTimeout(() => flash.style.opacity = 0, 200);
                    showMessage("TOOK DAMAGE!", "#f00");

                    if (playerHP <= 0) {
                        endFight(false);
                        return;
                    }
                }
                enemyState = 'RECOVERING';
                setTimeout(() => {
                    enemyState = 'IDLE';
                }, 1000); // Vulnerable for 1s
            }, 200);
        }

        function showMessage(msg, color) {
            statusEl.textContent = msg;
            statusEl.style.color = color;
            statusEl.style.opacity = 1;
            setTimeout(() => statusEl.style.opacity = 0, 1500);
        }

        function endFight(won) {
            isFighting = false;
            if (won) {
                statusEl.textContent = "VICTORY!";
                statusEl.style.color = "#0f0";
            } else {
                statusEl.textContent = "DEFEAT!";
                statusEl.style.color = "#f00";
            }
            // Send message to parent
            setTimeout(() => {
                window.parent.postMessage({ type: 'fight-result', won: won }, '*');
            }, 1000);
        }

        // --- INPUTS ---
        window.addEventListener('mousedown', (e) => {
            if (e.button === 0) attack();
            if (e.button === 2) setBlock(true);
        });
        window.addEventListener('mouseup', (e) => {
            if (e.button === 2) setBlock(false);
        });
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') setBlock(true);
            if (e.code === 'KeyW') keys.w = true;
            if (e.code === 'KeyS') keys.s = true;
            if (e.code === 'KeyA') keys.a = true;
            if (e.code === 'KeyD') keys.d = true;
        });
        window.addEventListener('keyup', (e) => {
            if (e.code === 'Space') setBlock(false);
            if (e.code === 'KeyW') keys.w = false;
            if (e.code === 'KeyS') keys.s = false;
            if (e.code === 'KeyA') keys.a = false;
            if (e.code === 'KeyD') keys.d = false;
        });
        // Prevent context menu
        window.addEventListener('contextmenu', e => e.preventDefault());

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            // Movement logic
            if (isFighting && playerHP > 0) {
                const speed = 0.1;
                let dx = 0;
                let dz = 0;

                if (keys.w) dz -= speed;
                if (keys.s) dz += speed;
                if (keys.a) dx -= speed;
                if (keys.d) dx += speed;

                if (dx !== 0 || dz !== 0) {
                    const nextX = camera.position.x + dx;
                    const nextZ = camera.position.z + dz;
                    const dist = Math.sqrt(nextX * nextX + nextZ * nextZ);

                    // Collision radius (prevent getting closer than 2 units)
                    if (dist > 2.0) {
                        camera.position.x = nextX;
                        camera.position.z = nextZ;
                    }
                }
                camera.lookAt(0, 1.6, 0); // Always face the enemy
            }

            updateEnemyAI();

            // Breathing / Idle
            if (isFighting && enemyHP > 0) {
                const breathing = Math.sin(Date.now() * 0.003) * 0.05;
                if (enemyState === 'CHARGING') {
                    enemy.position.x = (Math.random() - 0.5) * 0.2; // Shake
                } else {
                    enemy.position.x = 0;
                }

                if (enemyState === 'ATTACKING') {
                    // Quick lunge visual handled in time, or just lerp here if we wanted complex
                    enemy.position.z = Math.min(camera.position.z - 1, enemy.position.z + 0.2);
                } else {
                    // return to start
                    enemy.position.z = THREE.MathUtils.lerp(enemy.position.z, 0, 0.1);
                }

                enemy.position.y = (isBoss ? 2.5 : 1.6) + breathing;
            }

            renderer.render(scene, camera);
        }
        animate();

    </script>
</body>

</html>